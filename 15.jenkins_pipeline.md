# üöÄ Secci√≥n 15: Jenkins Pipeline

---

## üìò Introducci√≥n a Pipeline

`Jenkins Pipeline` nos da la capacidad de escribir los `Build Steps` en forma de c√≥digo. Esto significa que podemos
definir las etapas del ciclo de `CI/CD` de manera expl√≠cita:

- `Build` ‚Üí Compilar la aplicaci√≥n.
- `Test` ‚Üí Ejecutar pruebas autom√°ticas.
- `Deploy` ‚Üí Desplegar la aplicaci√≥n en un entorno.

‚ö†Ô∏è `Nota pedag√≥gica`: Estas tres etapas son las m√°s comunes en cualquier proceso de integraci√≥n y entrega continua,
y casi siempre se repiten en proyectos reales.

### üéØ ¬øPor qu√© escribir Pipeline como c√≥digo?

Las organizaciones modernas trabajan con el concepto de `Pipeline-as-Code`, el cual proporciona beneficios clave:

#### ‚≠ê Ventajas principales

- üì¶ `Versionamiento (SCM)`: El pipeline se guarda en un archivo (`Jenkinsfile`) dentro del repositorio, lo que permite
  rastrear cambios, hacer code review y mantener historial.
- üõ†Ô∏è `Reproducibilidad`: Todo el proceso de compilaci√≥n, pruebas y despliegue queda definido como c√≥digo.
  Nada queda ‚Äúen la memoria‚Äù del administrador.
- ‚ôªÔ∏è `Automatizaci√≥n real`: `Jenkins` puede ejecutar el Pipeline autom√°ticamente en cada push, PR o evento.
- üöÄ `Portabilidad entre Jobs`: Puedes copiar, clonar o refactorizar pipelines f√°cilmente.
- üß™ `Estabilidad`: Menos dependencias de la interfaz gr√°fica ‚Üí menos errores humanos.

üí° Nota:
> En empresas, tener el `Jenkinsfile` dentro del repo es considerado la mejor pr√°ctica est√°ndar. Queda prohibido
> depender solo de configuraciones por UI.

### üîç Diferencia entre Jenkins Pipeline vs Jenkins Job DSL

Ambos permiten definir el proceso de CI/CD como c√≥digo, pero su enfoque es distinto:

#### üß¨ Jenkins Pipeline

- Es un `tipo de Job` en Jenkins.
- Se encarga directamente del flujo de CI/CD: `Build` ‚Üí `Test` ‚Üí `Deploy`.
- La definici√≥n del `Pipeline` vive en un `Jenkinsfile`.

#### üè≠ Jenkins Job DSL

- Es un mecanismo para generar Jobs desde c√≥digo.
- Usado para crear y configurar otros Jobs (incluidos pipelines).
- Utiliza Groovy, pero NO para el flujo CI/CD, sino para crear Jobs, vistas, carpetas, etc.

#### ü§ù C√≥mo conviven

En empresas es muy com√∫n:

- Usar `Job DSL` para crear autom√°ticamente:
    - carpetas
    - multibranch pipelines
    - jobs de librer√≠as compartidas
- Usar `Pipeline` como el contenido del `Jenkinsfile` dentro del proyecto.

#### üìå Ejemplo t√≠pico real:

Un repositorio `infra-jenkins` contiene los scripts DSL para generar Jobs. El repositorio de la app contiene
el `Jenkinsfile` con el pipeline real.

### üõ†Ô∏è Formas de crear Jenkins Pipelines

Jenkins ofrece dos maneras de crear un Pipeline:

#### 1. Desde la Interfaz de Usuario (UI)

- Se crea un Job tipo `Pipeline` o `Multibranch Pipeline`.
- C√≥digo del pipeline se escribe directamente en Jenkins o se le indica d√≥nde est√° el `Jenkinsfile`.

#### 2. Usando DSL / Jenkinsfile (recomendado)

- Se crea un archivo `Jenkinsfile` en el repositorio.
- Jenkins detecta cambios autom√°ticamente.
- Es la forma usada en empresas modernas.

### üßë‚Äçüíª Lenguajes para escribir un Jenkins Pipeline

Jenkins tiene dos estilos principales:

#### üüß 1. Scripted Pipeline (Groovy puro)

- Basado en Groovy ‚Äúcl√°sico‚Äù.
- Muy flexible y expresivo.
- M√°s dif√≠cil de mantener.
- Hoy se usa solo en casos muy espec√≠ficos.

#### üü© 2. Declarative Pipeline (DSL moderno)

- Sigue una estructura clara: `pipeline { ... }`
- M√°s legible, m√°s seguro y con validaciones.
- Recomendado en empresas.
- Permite features avanzadas como:
    - environment
    - options
    - post
    - stages paralelos, etc.

> üìå `Mejor pr√°ctica actual`: Usar `Declarative Pipeline` junto con librer√≠as compartidas para l√≥gica compleja.

### üß± Etapas t√≠picas de un Jenkins Pipeline

En un proyecto est√°ndar, las etapas m√°s comunes son:

#### üèóÔ∏è Build

- Compilar la aplicaci√≥n.
- Instalar dependencias (Maven, Gradle, NPM, etc.)
- Generar artefactos (ej. .jar, .war, contenedores Docker).

#### üß™ Test

- Ejecutar pruebas unitarias, integraci√≥n o est√°ticas.
- Generar reportes (JUnit, Jacoco, SonarQube).
- Validar calidad del c√≥digo antes de desplegar.

#### üöÄ Deploy

- Publicar artefactos (Artifactory, Nexus).
- Puede incluir pasos de infraestructura (Docker, Kubernetes, servidores).
- Desplegar en dev/QA/prod (Kubernetes, EC2, etc.)

### üìå Conclusi√≥n

- Jenkins Pipeline convierte el ciclo de CI/CD en c√≥digo versionable.
- Se diferencia de Job DSL en que Pipeline ejecuta directamente las etapas, mientras que DSL crea jobs.
- Puede escribirse en Groovy (Scripted) o en Declarative DSL, siendo este √∫ltimo m√°s sencillo y recomendado.
- Las etapas t√≠picas son `Build` ‚Üí `Test` ‚Üí `Deploy`, reflejando el flujo est√°ndar de cualquier proyecto moderno.

## üìÑ C√≥digo Pipeline (Jenkinsfile)

El archivo `Jenkinsfile` define el flujo completo de un pipeline en Jenkins usando `Pipeline as Code`, lo que permite:

- ‚úîÔ∏è Versionarlo en el repositorio (Git).
- ‚úîÔ∏è Revisiones de c√≥digo y PRs para cambios en el pipeline.
- ‚úîÔ∏è Reproducibilidad entre entornos.
- ‚úîÔ∏è Trazabilidad del proceso de CI/CD.

Este archivo puede escribirse con la sintaxis `Declarative Pipeline` (m√°s com√∫n en empresas) o
`Scripted Pipeline` (m√°s flexible pero menos legible). `Aqu√≠ trabajaremos con el estilo Declarativo`.

### üìò Ejemplo completo de Jenkinsfile (Declarative Pipeline)

Este ejemplo muestra un pipeline t√≠pico con las fases est√°ndar de CI/CD:

> `Build` ‚Üí `Test` ‚Üí `Build Docker` ‚Üí `Deploy`.

````groovy
pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                echo 'Compilando la aplicaci√≥n...'
                sh 'mvn clean package -DskipTests'
            }
        }

        stage('Test') {
            steps {
                echo 'Ejecutando pruebas...'
                sh 'mvn test'
            }
        }

        stage('Docker Build') {
            steps {
                echo 'Construyendo imagen Docker...'
                sh 'docker build -t mi-app:latest .'
            }
        }

        stage('Deploy') {
            steps {
                echo 'Desplegando la aplicaci√≥n...'
                sh 'docker run -d --name mi-app-container -p 8080:8080 mi-app:latest'
            }
        }
    }
}
````

#### üîé Explicaci√≥n l√≠nea por l√≠nea

- üß© `pipeline`. Define que el archivo contiene un `Declarative Pipeline` y agrupa toda la configuraci√≥n del proceso.
- ‚öôÔ∏è `agent any`
    - Asigna un ejecutor (worker/agent) donde se ejecutar√° el pipeline.
    - `any` indica: *‚Äúusa cualquier agente disponible en el cluster Jenkins‚Äù*.
    - ‚ö†Ô∏è En empresas se utilizan agentes especializados:
        - `docker` (con contenedores ef√≠meros)
        - `linux` / `windows` / `arm64`
        - agentes con JDK, Maven, Node, etc.
- üß± `stages`
    - Agrupa todas las etapas del pipeline.
    - Un pipeline empresarial puede incluir 8‚Äì20 stages:
        - Linting
        - SonarQube
        - Build
        - Unit Tests
        - Integration Tests
        - Package
        - Docker Build
        - Push to Registry
        - Deploy a Dev
        - Deploy a QA
        - Deploy a Prod (manual approval)
- üî® `steps`
    - Son los pasos individuales que se ejecutan dentro de cada stage.
    - Todos los comandos `sh` o acciones declarativas se colocan aqu√≠.

#### üèóÔ∏è Etapa Build

````groovy
stage('Build') {
    steps {
        echo 'Compilando la aplicaci√≥n...'
        sh 'mvn clean package -DskipTests'
    }
}
````

- Se compila y empaqueta la aplicaci√≥n.
- Se omiten las pruebas para hacer m√°s r√°pido el build (estrategia com√∫n en pipelines modernos).

üí° Mejores pr√°cticas reales

- No compilar dos veces.
    - Compilar aqu√≠ ‚Üí generar artefacto ‚Üí reutilizar ese mismo artefacto en etapas posteriores.
- Generar artefactos reproducibles:
    - `.jar`, `.war`, `.zip`, `im√°genes Docker`.
- Subir artefactos a un repositorio central:
    - `Nexus`, `Artifactory`, `JFrog`, `GitHub Packages`.

#### üß™ Etapa Test

````groovy
stage('Test') {
    steps {
        echo 'Ejecutando pruebas...'
        sh 'mvn test'
    }
}
````

Ejecuta pruebas unitarias y/o de integraci√≥n.

üí° Mejores pr√°cticas en empresas

- Integrar `SonarQube` aqu√≠ (o antes): `sh 'mvn sonar:sonar'`.
- Publicar reportes:
    - JUnit
    - Jacoco (coverage)
- Bloquear despliegue si no pasa la calidad m√≠nima.

#### üê≥ Etapa Docker Build

````groovy
stage('Docker Build') {
    steps {
        echo 'Construyendo imagen Docker...'
        sh 'docker build -t mi-app:latest .'
    }
}
````

Crea una imagen Docker basada en el c√≥digo reci√©n construido.

üí° Mejores pr√°cticas modernas

- Usar versionado sem√°ntico en tags: `mi-app:${BUILD_NUMBER}`
- Usar `Docker Buildx` o `kaniko` para builds m√°s r√°pidos.
- Subir la imagen a un registry:
    - Docker Hub
    - GitHub Container Registry
    - Amazon ECR
    - Google GCR
    - Azure ACR

#### üöÄ Etapa Deploy

````groovy
stage('Deploy') {
    steps {
        echo 'Desplegando la aplicaci√≥n...'
        sh 'docker run -d --name mi-app-container -p 8080:8080 mi-app:latest'
    }
}
````

Despliega la imagen reci√©n creada.

üí° Buenas pr√°cticas reales

- No hacer `docker run` directo en PROD.
- Las empresas usan:
    - Kubernetes (EKS, AKS, GKE)
    - ECS
    - Nomad
    - Docker Swarm (menos com√∫n hoy)
- Jenkins `solo orquesta`, pero no debe encargarse directamente del hosting.

### ‚ö†Ô∏è Nota t√©cnica (Muy importante en empresas)

Cuando usas Jenkins dentro de Docker con acceso al host: `Jenkins` usa `Docker-outside-of-Docker` (DooD)

Significa:

- `Jenkins` no tiene su propio `Docker Engine`.
- Usa el `CLI Docker` instalado dentro del contenedor.
- Se conecta al `Docker` del host mediante el socket: `/var/run/docker.sock`.

Esto permite:

- Construir im√°genes
- Ejecutar contenedores
- Parar/limpiar contenedores
- Usar Docker Compose

Ô∏è‚ö†Ô∏è Riesgos reales a considerar

- Cualquier proceso dentro del contenedor Jenkins tiene permisos de root en el host.
- Las empresas suelen aislar los agentes con:
    - Agentes Kubernetes
    - Jenkins agents con privilegios m√≠nimos
    - Containers sin acceso al socket Docker

### üìå Conclusi√≥n

Este `Jenkinsfile`:

- Define un pipeline declarativo completo.
- Contiene las 4 etapas m√°s comunes en empresas: `Build` ‚Üí `Test` ‚Üí `Build Docker` ‚Üí `Deploy`.
- Est√° preparado para integrarse con herramientas reales como `SonarQube`, `Nexus`, `Docker Registry`, etc.
- Est√° escrito siguiendo mejores pr√°cticas modernas de CI/CD.

## üöÄ Primer Pipeline en Jenkins

En esta secci√≥n crearemos nuestro primer `Pipeline Declarativo` en Jenkins y analizaremos c√≥mo ejecutar m√∫ltiples pasos,
visualizar resultados e instalar herramientas adicionales para entender mejor la ejecuci√≥n del pipeline.

### üîå Verificando la instalaci√≥n del plugin Pipeline

El contenedor oficial de Jenkins incluye por defecto el `Pipeline Plugin`, tambi√©n conocido como:

- Workflow API
- Declarative Pipeline
- Scripted Pipeline Runtime

Para verificar que est√° presente, ingresamos a: `Manage Jenkins ‚Üí Plugins ‚Üí Installed plugins`. Como se observa en la
imagen, el plugin Pipeline ya est√° instalado.

![01.png](assets/section-15/01.png)

En empresas, Jenkins casi siempre se despliega con los plugins esenciales ya preinstalados mediante:

- Jenkins Configuration as Code (JCasC)
- Im√°genes Docker personalizadas
- Scripts Groovy de inicializaci√≥n

Esto garantiza consistencia entre entornos.

### üÜï Creando nuestro primer Pipeline

Creamos una `nueva tarea (job)` llamado `primer-pripeline` y, en lugar de seleccionar ‚ÄúFreestyle Project‚Äù, elegimos
`Pipeline`, que permite definir automatizaciones completas usando c√≥digo.

![02.png](assets/section-15/02.png)

- Los pipelines deben escribirse siempre como c√≥digo para ser versionados.
- Los Freestyle Jobs est√°n pr√°cticamente obsoletos para CI/CD moderno.

### ‚úçÔ∏è Definiendo el Pipeline Script

Al ingresar al nuevo job `primer-pripeline`, veremos opciones similares a las de un job cl√°sico, salvo que:

- Ya no existen `Build Steps`.
- En su lugar aparece la secci√≥n `Pipeline`.

Esta secci√≥n permite dos modos principales:

- 1Ô∏è‚É£ `Pipeline Script`. Escribir el pipeline directamente en el editor de Jenkins (modo recomendado solo para pruebas
  o demos).
- 2Ô∏è‚É£ `Pipeline Script from SCM`. Usar un repositorio Git para cargar un `Jenkinsfile` real. Este es el m√©todo est√°ndar
  en empresas.

Por ahora usaremos el modo manual (`Pipeline Script`).

### üß± Primer Pipeline simple (solo imprime mensajes)

````groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                echo 'Compilando la aplicaci√≥n...'
            }
        }
        stage('Test') {
            steps {
                echo 'Ejecutando pruebas...'
            }
        }
        stage('Deploy') {
            steps {
                echo 'Desplegando la aplicaci√≥n...'
            }
        }
    }
}
````

En la interfaz se ver√° as√≠:

![03.png](assets/section-15/03.png)

### ‚ñ∂Ô∏è Ejecutando el Pipeline

Al pulsar `Construir ahora`, Jenkins procesar√° las etapas secuencialmente.

![04.png](assets/section-15/04.png)

### üìú Revisando el Console Output

En el log de la ejecuci√≥n podemos ver:

- El pipeline fue asignado a un ejecutor.
- Cada stage se ejecut√≥ correctamente.
- Todos los mensajes `echo` se imprimieron.

![05.png](assets/section-15/05.png)

üí° `Importante`. El `Console Output` es la herramienta principal para depurar errores en `Jenkins`.

## üîÑ Ejecutando m√∫ltiples pasos en una etapa

`Jenkins Pipeline` permite ejecutar m√∫ltiples comandos dentro del bloque `steps`. Cada `step` representa una acci√≥n
individual.

Documentaci√≥n oficial: https://www.jenkins.io/doc/pipeline/tour/running-multiple-steps/

### üìå Conceptos clave

- Un `step` = Un comando o acci√≥n individual.
- Si un step falla ‚Üí ‚ùå el pipeline se detiene.
- Si todos los steps completan ‚Üí ‚úîÔ∏è la etapa es exitosa.

### üêß Uso del paso `sh` en Linux / BSD / macOS

En sistemas tipo Unix, usamos `sh` para ejecutar comandos de shell:

````groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'echo "Compilando la aplicaci√≥n..."'
                sh '''
                    echo "Los pasos de shell multil√≠nea tambi√©n funcionan"
                    ls -lah
                    pwd
                '''
            }
        }
        stage('Test') {
            steps {
                echo 'Ejecutando pruebas...'
            }
        }
        stage('Deploy') {
            steps {
                echo 'Desplegando la aplicaci√≥n...'
            }
        }
    }
}
````

En la siguiente imagen se muestra c√≥mo quedar√≠a el c√≥digo anterior.

![06.png](assets/section-15/06.png)

Guardamos el nuevo pipeline con los m√∫ltiples pasos agregados y procedemos a construir la aplicaci√≥n. Vemos que
la construcci√≥n se realiz√≥ exitosamente.

![07.png](assets/section-15/07.png)

Ahora, si revisamos el log generado por la ejecuci√≥n `#4` vemos que los m√∫ltiples pasos se han ejecutado sin problemas.
Eso permiti√≥ que las siguientes etapas contin√∫en su ejecuci√≥n.

````bash
Started by user System Admin
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/jenkins_home/workspace/primer-pipeline
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Build)
[Pipeline] sh
+ echo Compilando la aplicaci√≥n...
Compilando la aplicaci√≥n...
[Pipeline] sh
+ echo Los pasos de shell multil√≠nea tambi√©n funcionan
Los pasos de shell multil√≠nea tambi√©n funcionan
+ ls -lah
total 8.0K
drwxr-xr-x  2 jenkins jenkins 4.0K Nov 28 18:15 .
drwxr-xr-x 17 jenkins jenkins 4.0K Nov 28 18:15 ..
+ pwd
/var/jenkins_home/workspace/primer-pipeline
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Test)
[Pipeline] echo
Ejecutando pruebas...
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Deploy)
[Pipeline] echo
Desplegando la aplicaci√≥n...
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS 
````

## üìä Instalaci√≥n del plugin Pipeline Stage View

Este plugin agrega una interfaz visual muy √∫til para ver:

- Etapas del pipeline
- Duraci√≥n por etapa
- Estado de cada ejecuci√≥n
- Paralelismo (si aplica)

Pasos para instalar:

![08.png](assets/section-15/08.png)

Habiendo instalado el plugin y reiniciado Jenkins (si se requiere reinicio manual ir a la siguiente direcci√≥n
`http://localhost:8080/safeRestart`), nos vamos a nuestro job `primer-pipeline` y vemos que ahora las ejecuciones
se muestran gr√°ficamente, incluso se muestran las etapas: Build | Test | Deploy y en cada fila el n√∫mero de ejecuci√≥n
realizada al job. Debajo de cada etapa se muestra el fondo en color verde indicando que esa etapa se realiz√≥ con √©xito.

- üü© Verde = √©xito
- üü• Rojo = fallo
- üü® Amarillo = inestable (usualmente por pruebas fallidas)

![09.png](assets/section-15/09.png)

### üß† Diferencias entre versiones de Jenkins

El instructor no necesit√≥ instalarlo porque:

- Algunas versiones antiguas (LTS previas) ven√≠an con este plugin preinstalado.
- En tu caso, la versi√≥n moderna del contenedor no incluye plugins adicionales para mantener la imagen m√°s ligera.

## Etapas paralelas y secuenciales

En el siguiente enlace encontraremos todo lo relacionado con la sintaxis de `Pipelines en Jenkins`:
`Pipeline Syntax`: https://www.jenkins.io/doc/book/pipeline/syntax/

En esta lecci√≥n vamos a modificar el `Pipeline script` del job `primer-pipeline` para ilustrar el comportamiento de las
etapas secuenciales y paralelas dentro de un mismo flujo.

### üß© Script del Pipeline (Secuencial + Paralelo)

````groovy
pipeline {
    agent any
    stages {
        stage('Secuencial') {
            stages {
                stage('Secuencial 1') {
                    steps {
                        echo "Secuencial: Parte 1"
                    }
                }
                stage('Secuencial 2') {
                    steps {
                        echo "Secuencial: Parte 2"
                    }
                }
                stage('Paralelo dentro de secuencial') {
                    parallel {
                        stage('Paralelo 1') {
                            steps {
                                echo "Paralelo en secuencial: Parte 1"
                            }
                        }
                        stage('Paralelo 2') {
                            steps {
                                echo "Paralelo en secuencial: Parte 2"
                            }
                        }
                    }
                }
            }
        }
    }
}
````

> üí° `Nota`: Aqu√≠ observamos c√≥mo `Jenkins` permite anidar bloques `stages` para ejecutar tareas secuenciales,
> y dentro de ellos incluir un bloque `parallel` que ejecuta etapas simult√°neamente.

### üñºÔ∏è Modificaci√≥n del Pipeline en Jenkins

En la siguiente imagen se puede ver la actualizaci√≥n del script dentro del job:

![10.png](assets/section-15/10.png)

### ‚ñ∂Ô∏è Ejecuci√≥n del Pipeline

Despu√©s de guardar los cambios, construimos nuevamente el job `primer-pipeline`. A continuaci√≥n se muestra el
log generado durante la ejecuci√≥n:

````bash
Started by user System Admin

[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins
 in /var/jenkins_home/workspace/primer-pipeline
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Secuencial)
[Pipeline] stage
[Pipeline] { (Secuencial 1)
[Pipeline] echo
Secuencial: Parte 1
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Secuencial 2)
[Pipeline] echo
Secuencial: Parte 2
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Paralelo dentro de secuencial)
[Pipeline] parallel
[Pipeline] { (Branch: Paralelo 1)
[Pipeline] { (Branch: Paralelo 2)
[Pipeline] stage
[Pipeline] { (Paralelo 1)
[Pipeline] stage
[Pipeline] { (Paralelo 2)
[Pipeline] echo
Paralelo en secuencial: Parte 1
[Pipeline] }
[Pipeline] echo
Paralelo en secuencial: Parte 2
[Pipeline] }
[Pipeline] // stage
[Pipeline] // stage
[Pipeline] }
[Pipeline] }
[Pipeline] // parallel
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS 
````

### üìä Visualizaci√≥n en el Pipeline Stage View

Tambi√©n podemos observar la ejecuci√≥n en la interfaz principal del job gracias al plugin `Pipeline Stage View`,
que muestra gr√°ficamente:

- las etapas secuenciales como columnas en orden lineal,
- y las etapas paralelas compartiendo una misma l√≠nea horizontal.

![11.png](assets/section-15/11.png)

### ‚öôÔ∏è Control de fallas en bloques paralelos

Podemos forzar que si una de las etapas dentro del bloque `parallel` falla, todas las dem√°s se aborten autom√°ticamente,
evitando procesos colgados o inconsistencias. Para eso necesitamos a√±adir `failFast` como valor `true` a la etapa
que contiene la etapa paralela.

üí° Ejemplo:

````bash 
...
stage('Paralelo dentro de secuencial') {
    failFast true
    parallel {
        stage('Paralelo 1') {
            steps {
                echo "Paralelo en secuencial: Parte 1"
            }
        }
        stage('Paralelo 2') {
            steps {
                echo "Paralelo en secuencial: Parte 2"
            }
        }
    }
}
...
````

üí¨ Explicaci√≥n t√©cnica:
> Usar `failFast` ayuda a evitar consumir recursos innecesarios cuando el resultado final del pipeline ya est√°
> comprometido por la falla de uno de los subprocesos.

## ‚≠ê Options, Timeout & Retry en Jenkins Pipeline

C√≥mo controlar tiempos, reintentos y configuraciones globales en Pipelines Declarativos (con buenas pr√°cticas reales)

üéØ Objetivo:
> Aprender a usar correctamente `retry`, `timeout` y `options` ‚Äîtres mecanismos cr√≠ticos para crear pipelines seguros,
> resilientes y predecibles.

üìö Fuente oficial:
[Timeouts, retries and more](https://www.jenkins.io/doc/pipeline/tour/running-multiple-steps/#timeouts-retries-and-more)

### üß© ¬øQu√© son Retry y Timeout?

- üîÅ `retry(n)`: Reintenta ejecutar uno o varios `steps` hasta que se completen correctamente.
- Muy √∫til para:
    - Steps que fallan de forma intermitente (red, API, despliegues fr√°giles)
    - Deploys que dependen de servicios externos
    - Scripts inestables o con flakiness


- ‚è≥ `timeout`: Cancelar√° la ejecuci√≥n de un bloque si tarda m√°s de lo configurado.
- Muy √∫til para:
    - Evitar hangs inesperados
    - Proteger agentes (que no queden ‚Äúcolgados‚Äù)
    - Detener scripts que pueden entrar en loops infinitos
    - Asegurar SLAs en pipelines largos

#### üîç Ejemplo explicado

````groovy
pipeline {
    agent any
    stages {
        stage('Deploy') {
            steps {
                retry(3) {
                    sh './flakey-deploy.sh'
                }

                timeout(time: 3, unit: 'MINUTES') {
                    sh './health-check.sh'
                }
            }
        }
    }
}
````

üß† ¬øQu√© est√° pasando?

1. üîÅ `retry(3)`
    - Ejecuta `./flakey-deploy.sh` hasta 3 veces.
    - Si una ejecuci√≥n tiene √©xito ‚Üí no contin√∫a reintentando.
    - Si todas fallan ‚Üí la etapa falla.


2. ‚è≥ `timeout(3 MINUTES)`
    - Intenta ejecutar `./health-check.sh`.
    - Si demora m√°s de 3 minutos:
        - Jenkins aborta el step
        - La etapa "Deploy" falla
        - El pipeline se detiene

üß± Importante
> Los steps como `retry` y `timeout` son wrappers, es decir, envoltorios que contienen otros steps dentro.

### üß™ Ejemplo 1: Timeout

üìç Modificamos el pipeline del job `primer-pipeline`:

````groovy
pipeline {
    agent any
    stages {
        stage('Deploy') {
            steps {
                retry(3) {
                    sh 'echo "Iniciando el deploy"'
                }

                timeout(time: 10, unit: 'SECONDS') {
                    sh 'sleep 15'
                }
            }
        }
    }
}
````

En la siguiente imagen vemos el c√≥digo anterior definido en el `Pipeline script`.

![12.png](assets/section-15/12.png)

Luego damos en `Save` y procedemos a construir el Job `primer-pipeline`.

![13.png](assets/section-15/13.png)

En este ejemplo:

- El timeout es de `10 segundos`
- El comando `sleep 15` tarda m√°s
    - Resultado esperado: El pipeline ser√° `abortado` porque el tiempo excede el l√≠mite.

![14.png](assets/section-15/14.png)

Si revisamos el `Console Output` de la construcci√≥n que fall√≥ podemos ver lo siguiente:

````bash
Started by user System Admin
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/jenkins_home/workspace/primer-pipeline
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Deploy)
[Pipeline] retry
[Pipeline] {
[Pipeline] sh
+ echo Iniciando el deploy
Iniciando el deploy
[Pipeline] }
[Pipeline] // retry
[Pipeline] timeout
Timeout set to expire in 10 sec
[Pipeline] {
[Pipeline] sh
+ sleep 15
Cancelling nested steps due to timeout
Sending interrupt signal to process
Terminated
script returned exit code 143
[Pipeline] }
[Pipeline] // timeout
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Timeout has been exceeded
org.jenkinsci.plugins.workflow.actions.ErrorAction$ErrorId: 9e123e4b-a55f-47e1-b6a0-d6c291b65ced
Finished: ABORTED 
````

Se observa:

- `Timeout set to expire in 10 sec`
- Se interrumpe con `Cancelling nested steps due to timeout`
- El pipeline termina en: `ABORTED`

> üí° Esto imita escenarios reales: scripts colgados, conexiones lentas, recursos saturados, etc.

### üß™ Ejemplo 2: Retry

````groovy
pipeline {
    agent any
    stages {
        stage('Deploy') {
            steps {
                timeout(time: 5, unit: 'SECONDS') {
                    retry(3) {
                        sh 'hola'
                    }
                }
            }
        }
    }
}
````

#### üîé ¬øPor qu√© fallar√°?

Porque `hola` **no es un comando v√°lido**, nos ‚Äúolvidamos‚Äù de `echo`. Cada ejecuci√≥n fallar√°, y `retry(3)` repetir√°
el intento 3 veces.

![15.png](assets/section-15/15.png)

Damos en `Save` y procedemos a realizar la construcci√≥n del job `primer-pipeline`.

![16.png](assets/section-15/16.png)

Como vemos en la imagen anterior, el resultado de la construcci√≥n falla. Salida notable del log:

````bash
Started by user System Admin
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/jenkins_home/workspace/primer-pipeline
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Deploy)
[Pipeline] timeout
Timeout set to expire in 5 sec
[Pipeline] {
[Pipeline] retry
[Pipeline] {
[Pipeline] sh
+ hola
/var/jenkins_home/workspace/primer-pipeline@tmp/durable-b1f6b6c7/script.sh.copy: 1: hola: not found
[Pipeline] }
ERROR: script returned exit code 127
Retrying
[Pipeline] {
[Pipeline] sh
+ hola
/var/jenkins_home/workspace/primer-pipeline@tmp/durable-b5ff0fd6/script.sh.copy: 1: hola: not found
[Pipeline] }
ERROR: script returned exit code 127
Retrying
[Pipeline] {
[Pipeline] sh
+ hola
/var/jenkins_home/workspace/primer-pipeline@tmp/durable-230d8437/script.sh.copy: 1: hola: not found
[Pipeline] }
[Pipeline] // retry
[Pipeline] }
[Pipeline] // timeout
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
ERROR: script returned exit code 127
Finished: FAILURE 
````

- ‚úîÔ∏è Finalmente ‚Üí El pipeline falla (`status: FAILURE`).
- ‚úîÔ∏è Se ve claramente c√≥mo trabaja `retry`.

### ‚öôÔ∏è Options ‚Äî Configuraci√≥n a nivel Pipeline

La directiva `options` permite configurar par√°metros del pipeline entero.

üîß Algunos ejemplos reales:

| Opci√≥n                      | Prop√≥sito                                     |
|-----------------------------|-----------------------------------------------|
| `timeout(...)`              | Limitar el tiempo total del pipeline          |
| `buildDiscarder(...)`       | Rotar builds antiguos (muy usado en empresas) |
| `timestamps()`              | A√±adir timestamps al console output           |
| `disableConcurrentBuilds()` | Evitar builds simult√°neas                     |
| `skipDefaultCheckout()`     | No hacer checkout autom√°tico del repositorio  |

#### üß© Ejemplo simple

````groovy
pipeline {
    agent any
    options {
        timeout(time: 1, unit: 'HOURS')
    }
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'
            }
        }
    }
}
````

‚û°Ô∏è Si el pipeline completa tarda m√°s de 1 hora ‚Üí ser√° abortada.

### üß™ Ejemplo real usando options dentro de un stage

````groovy
pipeline {
    agent any
    stages {
        stage('Secuencial') {
            options {
                timeout(time: 15, unit: 'SECONDS')
            }
            stages {
                stage('Secuencial 1') {
                    steps {
                        echo "Secuencial: Parte 1"
                    }
                }
                stage('Secuencial 2') {
                    steps {
                        sh 'sleep 16'
                    }
                }
            }
        }
    }
}
````

- ‚úî El timeout aplicado al stage es de 15 segundos
- ‚úî El comando tarda 16 segundos
- ‚ùå Resultado: ABORTED

![17.png](assets/section-15/17.png)

### üéØ Conclusi√≥n

Con `retry`, `timeout` y `options` elevas la calidad de tus pipelines, volvi√©ndolos:

- M√°s resilientes
- M√°s seguros
- M√°s predecibles
- M√°s profesionales

Y sobre todo, alineados con c√≥mo trabajan equipos DevOps en empresas reales.

## üîê Env Variables & Credentials (Variables de Entorno y Credenciales en Jenkins)

El manejo de `credenciales` y `variables de entorno` es uno de los pilares fundamentales en la construcci√≥n de
Pipelines seguros, mantenibles y reutilizables. En Jenkins, estos elementos permiten:

- Centralizar informaci√≥n sensible (usuarios, contrase√±as, tokens, claves).
- Controlar variable seg√∫n el ambiente (dev, qa, prod).
- Evitar exponer secretos en los logs del pipeline.
- Integrar herramientas externas (GitHub, DockerHub, SonarQube, Kubernetes, etc.).

### üîë Creando credenciales en Jenkins

Para crear credenciales en Jenkins:

`Administrar Jenkins` ‚Üí `Credentials` ‚Üí `seleccionar almac√©n (global en este ejemplo)` ‚Üí `Add credentials`

![18.png](assets/section-15/18.png)

En el formulario de `New credentials` definimos los siguientes valores:

- `King`: Username with password
- `Username`: qwerty
- `Password`: 1234
- `ID`: usuario1

![19.png](assets/section-15/19.png)

Creamos nuevas credenciales con los siguientes valores:

- `King`: Secret text
- `Secret`: 123456789
- `ID`: usuario2

![20.png](assets/section-15/20.png)

Finalmente, las dos credenciales definidas las vemos creadas en el `Global credentials (unrestricted)`.

![21.png](assets/section-15/21.png)

### üåç Environment

La directiva `environment` permite definir variables de entorno visibles en:

- Todo el pipeline (si est√° a nivel ra√≠z).
- Un stage espec√≠fico (si se define dentro de `stage`).
- Un bloque interno, como `script`.

Tambi√©n permite utilizar el m√©todo especial: `credentials('ID')`. El cual expone los valores de credenciales como
variables de entorno automatizadas.

### üß™ Ejemplo 1 ‚Äî Username/Password dentro de un Stage

Veamos el siguiente ejemplo:

````groovy
pipeline {
    agent any
    stages {
        stage('Ejemplo Username/Password') {
            environment {
                CRED_USUARIO = credentials('usuario1')
            }
            steps {
                sh 'echo "El usuario es $CRED_USUARIO_USR"'
                sh 'echo "La contrase√±a es $CRED_USUARIO_PSW"'
            }
        }
    }
}
````

Cuando se usa: `CRED_USUARIO = credentials('usuario1')`, Jenkins crea internamente:

- `$CRED_USUARIO_USR` ‚Üí username
- `$CRED_USUARIO_PSW` ‚Üí password

Y adem√°s activa autom√°ticamente un bloque `withCredentials` para ocultarlos en los logs.

üí° Nota de seguridad:
> Los valores sensibles jam√°s aparecer√°n en texto plano. Jenkins autom√°ticamente enmascara cualquier coincidencia.

![22.png](assets/section-15/22.png)

Si construimos el job `primer-pipeline` vemos que la construcci√≥n es exitosa.

![23.png](assets/section-15/23.png)

Ahora, si revisamos el `Console Output`, vemos que nos est√° mostrando correctamente los mensajes definidos junto a
los valores de la variable de entorno. Obviamente, las contrase√±as no los va a mostrar por eso los muestra en
asteriscos.

````bash
Started by user System Admin
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/jenkins_home/workspace/primer-pipeline
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Ejemplo Username/Password)
[Pipeline] withCredentials
Masking supported pattern matches of $CRED_USUARIO or $CRED_USUARIO_PSW
[Pipeline] {
[Pipeline] sh
+ echo El usuario es qwerty
El usuario es qwerty
[Pipeline] sh
+ echo La contrase√±a es ****
La contrase√±a es ****
[Pipeline] }
[Pipeline] // withCredentials
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS
````

### üß™ Ejemplo 2 ‚Äî Secret Text como variable global

Aqu√≠ definimos la variable `a nivel del pipelin`e, no solo a nivel de un stage.

````groovy
pipeline {
    agent any
    environment {
        SECRET_TEXT = credentials('usuario2')
    }
    stages {
        stage('Ejemplo para Secret Text') {
            steps {
                sh 'echo $SECRET_TEXT'
            }
        }
    }
}
````

Puntos claves:

- ‚úî `credentials('usuario2')` expone una √∫nica variable:
    - `$SECRET_TEXT` ‚Üí contendr√° el secret directamente
- ‚úî Jenkins enmascara el valor en los logs. Siempre ver√°s `****`.

‚öôÔ∏è Explicaci√≥n t√©cnica:
> El plugin `Credentials Binding` detecta patrones sensibles y reemplaza cualquier coincidencia con asteriscos para
> evitar
> filtrado accidental.

````bash
Started by user System Admin
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/jenkins_home/workspace/primer-pipeline
[Pipeline] {
[Pipeline] withCredentials
Masking supported pattern matches of $SECRET_TEXT
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Ejemplo para Secret Text)
[Pipeline] sh
+ echo ****
****
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // withCredentials
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS 
````

En producci√≥n, preferir integraci√≥n con Vault, AWS Secrets Manager o Azure Key Vault. Jenkins solo deber√≠a pedir los
secretos, no almacenarlos.
