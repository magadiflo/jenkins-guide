# ğŸš€ SecciÃ³n 15: Jenkins Pipeline

---

## ğŸ“˜ IntroducciÃ³n a Pipeline

`Jenkins Pipeline` nos da la capacidad de escribir los `Build Steps` en forma de cÃ³digo. Esto significa que podemos
definir las etapas del ciclo de `CI/CD` de manera explÃ­cita:

- `Build` â†’ Compilar la aplicaciÃ³n.
- `Test` â†’ Ejecutar pruebas automÃ¡ticas.
- `Deploy` â†’ Desplegar la aplicaciÃ³n en un entorno.

âš ï¸ `Nota pedagÃ³gica`: Estas tres etapas son las mÃ¡s comunes en cualquier proceso de integraciÃ³n y entrega continua,
y casi siempre se repiten en proyectos reales.

### ğŸ¯ Â¿Por quÃ© escribir Pipeline como cÃ³digo?

Las organizaciones modernas trabajan con el concepto de `Pipeline-as-Code`, el cual proporciona beneficios clave:

#### â­ Ventajas principales

- ğŸ“¦ `Versionamiento (SCM)`: El pipeline se guarda en un archivo (`Jenkinsfile`) dentro del repositorio, lo que permite
  rastrear cambios, hacer code review y mantener historial.
- ğŸ› ï¸ `Reproducibilidad`: Todo el proceso de compilaciÃ³n, pruebas y despliegue queda definido como cÃ³digo.
  Nada queda â€œen la memoriaâ€ del administrador.
- â™»ï¸ `AutomatizaciÃ³n real`: `Jenkins` puede ejecutar el Pipeline automÃ¡ticamente en cada push, PR o evento.
- ğŸš€ `Portabilidad entre Jobs`: Puedes copiar, clonar o refactorizar pipelines fÃ¡cilmente.
- ğŸ§ª `Estabilidad`: Menos dependencias de la interfaz grÃ¡fica â†’ menos errores humanos.

ğŸ’¡ Nota:
> En empresas, tener el `Jenkinsfile` dentro del repo es considerado la mejor prÃ¡ctica estÃ¡ndar. Queda prohibido
> depender solo de configuraciones por UI.

### ğŸ” Diferencia entre Jenkins Pipeline vs Jenkins Job DSL

Ambos permiten definir el proceso de CI/CD como cÃ³digo, pero su enfoque es distinto:

#### ğŸ§¬ Jenkins Pipeline

- Es un `tipo de Job` en Jenkins.
- Se encarga directamente del flujo de CI/CD: `Build` â†’ `Test` â†’ `Deploy`.
- La definiciÃ³n del `Pipeline` vive en un `Jenkinsfile`.

#### ğŸ­ Jenkins Job DSL

- Es un mecanismo para generar Jobs desde cÃ³digo.
- Usado para crear y configurar otros Jobs (incluidos pipelines).
- Utiliza Groovy, pero NO para el flujo CI/CD, sino para crear Jobs, vistas, carpetas, etc.

#### ğŸ¤ CÃ³mo conviven

En empresas es muy comÃºn:

- Usar `Job DSL` para crear automÃ¡ticamente:
    - carpetas
    - multibranch pipelines
    - jobs de librerÃ­as compartidas
- Usar `Pipeline` como el contenido del `Jenkinsfile` dentro del proyecto.

#### ğŸ“Œ Ejemplo tÃ­pico real:

Un repositorio `infra-jenkins` contiene los scripts DSL para generar Jobs. El repositorio de la app contiene
el `Jenkinsfile` con el pipeline real.

### ğŸ› ï¸ Formas de crear Jenkins Pipelines

Jenkins ofrece dos maneras de crear un Pipeline:

#### 1. Desde la Interfaz de Usuario (UI)

- Se crea un Job tipo `Pipeline` o `Multibranch Pipeline`.
- CÃ³digo del pipeline se escribe directamente en Jenkins o se le indica dÃ³nde estÃ¡ el `Jenkinsfile`.

#### 2. Usando DSL / Jenkinsfile (recomendado)

- Se crea un archivo `Jenkinsfile` en el repositorio.
- Jenkins detecta cambios automÃ¡ticamente.
- Es la forma usada en empresas modernas.

### ğŸ§‘â€ğŸ’» Lenguajes para escribir un Jenkins Pipeline

Jenkins tiene dos estilos principales:

#### ğŸŸ§ 1. Scripted Pipeline (Groovy puro)

- Basado en Groovy â€œclÃ¡sicoâ€.
- Muy flexible y expresivo.
- MÃ¡s difÃ­cil de mantener.
- Hoy se usa solo en casos muy especÃ­ficos.

#### ğŸŸ© 2. Declarative Pipeline (DSL moderno)

- Sigue una estructura clara: `pipeline { ... }`
- MÃ¡s legible, mÃ¡s seguro y con validaciones.
- Recomendado en empresas.
- Permite features avanzadas como:
    - environment
    - options
    - post
    - stages paralelos, etc.

> ğŸ“Œ `Mejor prÃ¡ctica actual`: Usar `Declarative Pipeline` junto con librerÃ­as compartidas para lÃ³gica compleja.

### ğŸ§± Etapas tÃ­picas de un Jenkins Pipeline

En un proyecto estÃ¡ndar, las etapas mÃ¡s comunes son:

#### ğŸ—ï¸ Build

- Compilar la aplicaciÃ³n.
- Instalar dependencias (Maven, Gradle, NPM, etc.)
- Generar artefactos (ej. .jar, .war, contenedores Docker).

#### ğŸ§ª Test

- Ejecutar pruebas unitarias, integraciÃ³n o estÃ¡ticas.
- Generar reportes (JUnit, Jacoco, SonarQube).
- Validar calidad del cÃ³digo antes de desplegar.

#### ğŸš€ Deploy

- Publicar artefactos (Artifactory, Nexus).
- Puede incluir pasos de infraestructura (Docker, Kubernetes, servidores).
- Desplegar en dev/QA/prod (Kubernetes, EC2, etc.)

### ğŸ“Œ ConclusiÃ³n

- Jenkins Pipeline convierte el ciclo de CI/CD en cÃ³digo versionable.
- Se diferencia de Job DSL en que Pipeline ejecuta directamente las etapas, mientras que DSL crea jobs.
- Puede escribirse en Groovy (Scripted) o en Declarative DSL, siendo este Ãºltimo mÃ¡s sencillo y recomendado.
- Las etapas tÃ­picas son `Build` â†’ `Test` â†’ `Deploy`, reflejando el flujo estÃ¡ndar de cualquier proyecto moderno.

## ğŸ“„ CÃ³digo Pipeline (Jenkinsfile)

El archivo `Jenkinsfile` define el flujo completo de un pipeline en Jenkins usando `Pipeline as Code`, lo que permite:

- âœ”ï¸ Versionarlo en el repositorio (Git).
- âœ”ï¸ Revisiones de cÃ³digo y PRs para cambios en el pipeline.
- âœ”ï¸ Reproducibilidad entre entornos.
- âœ”ï¸ Trazabilidad del proceso de CI/CD.

Este archivo puede escribirse con la sintaxis `Declarative Pipeline` (mÃ¡s comÃºn en empresas) o
`Scripted Pipeline` (mÃ¡s flexible pero menos legible). `AquÃ­ trabajaremos con el estilo Declarativo`.

### ğŸ“˜ Ejemplo completo de Jenkinsfile (Declarative Pipeline)

Este ejemplo muestra un pipeline tÃ­pico con las fases estÃ¡ndar de CI/CD:

> `Build` â†’ `Test` â†’ `Build Docker` â†’ `Deploy`.

````groovy
pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                echo 'Compilando la aplicaciÃ³n...'
                sh 'mvn clean package -DskipTests'
            }
        }

        stage('Test') {
            steps {
                echo 'Ejecutando pruebas...'
                sh 'mvn test'
            }
        }

        stage('Docker Build') {
            steps {
                echo 'Construyendo imagen Docker...'
                sh 'docker build -t mi-app:latest .'
            }
        }

        stage('Deploy') {
            steps {
                echo 'Desplegando la aplicaciÃ³n...'
                sh 'docker run -d --name mi-app-container -p 8080:8080 mi-app:latest'
            }
        }
    }
}
````

#### ğŸ” ExplicaciÃ³n lÃ­nea por lÃ­nea

- ğŸ§© `pipeline`. Define que el archivo contiene un `Declarative Pipeline` y agrupa toda la configuraciÃ³n del proceso.
- âš™ï¸ `agent any`
    - Asigna un ejecutor (worker/agent) donde se ejecutarÃ¡ el pipeline.
    - `any` indica: *â€œusa cualquier agente disponible en el cluster Jenkinsâ€*.
    - âš ï¸ En empresas se utilizan agentes especializados:
        - `docker` (con contenedores efÃ­meros)
        - `linux` / `windows` / `arm64`
        - agentes con JDK, Maven, Node, etc.
- ğŸ§± `stages`
    - Agrupa todas las etapas del pipeline.
    - Un pipeline empresarial puede incluir 8â€“20 stages:
        - Linting
        - SonarQube
        - Build
        - Unit Tests
        - Integration Tests
        - Package
        - Docker Build
        - Push to Registry
        - Deploy a Dev
        - Deploy a QA
        - Deploy a Prod (manual approval)
- ğŸ”¨ `steps`
    - Son los pasos individuales que se ejecutan dentro de cada stage.
    - Todos los comandos `sh` o acciones declarativas se colocan aquÃ­.

#### ğŸ—ï¸ Etapa Build

````groovy
stage('Build') {
    steps {
        echo 'Compilando la aplicaciÃ³n...'
        sh 'mvn clean package -DskipTests'
    }
}
````

- Se compila y empaqueta la aplicaciÃ³n.
- Se omiten las pruebas para hacer mÃ¡s rÃ¡pido el build (estrategia comÃºn en pipelines modernos).

ğŸ’¡ Mejores prÃ¡cticas reales

- No compilar dos veces.
    - Compilar aquÃ­ â†’ generar artefacto â†’ reutilizar ese mismo artefacto en etapas posteriores.
- Generar artefactos reproducibles:
    - `.jar`, `.war`, `.zip`, `imÃ¡genes Docker`.
- Subir artefactos a un repositorio central:
    - `Nexus`, `Artifactory`, `JFrog`, `GitHub Packages`.

#### ğŸ§ª Etapa Test

````groovy
stage('Test') {
    steps {
        echo 'Ejecutando pruebas...'
        sh 'mvn test'
    }
}
````

Ejecuta pruebas unitarias y/o de integraciÃ³n.

ğŸ’¡ Mejores prÃ¡cticas en empresas

- Integrar `SonarQube` aquÃ­ (o antes): `sh 'mvn sonar:sonar'`.
- Publicar reportes:
    - JUnit
    - Jacoco (coverage)
- Bloquear despliegue si no pasa la calidad mÃ­nima.

#### ğŸ³ Etapa Docker Build

````groovy
stage('Docker Build') {
    steps {
        echo 'Construyendo imagen Docker...'
        sh 'docker build -t mi-app:latest .'
    }
}
````

Crea una imagen Docker basada en el cÃ³digo reciÃ©n construido.

ğŸ’¡ Mejores prÃ¡cticas modernas

- Usar versionado semÃ¡ntico en tags: `mi-app:${BUILD_NUMBER}`
- Usar `Docker Buildx` o `kaniko` para builds mÃ¡s rÃ¡pidos.
- Subir la imagen a un registry:
    - Docker Hub
    - GitHub Container Registry
    - Amazon ECR
    - Google GCR
    - Azure ACR

#### ğŸš€ Etapa Deploy

````groovy
stage('Deploy') {
    steps {
        echo 'Desplegando la aplicaciÃ³n...'
        sh 'docker run -d --name mi-app-container -p 8080:8080 mi-app:latest'
    }
}
````

Despliega la imagen reciÃ©n creada.

ğŸ’¡ Buenas prÃ¡cticas reales

- No hacer `docker run` directo en PROD.
- Las empresas usan:
    - Kubernetes (EKS, AKS, GKE)
    - ECS
    - Nomad
    - Docker Swarm (menos comÃºn hoy)
- Jenkins `solo orquesta`, pero no debe encargarse directamente del hosting.

### âš ï¸ Nota tÃ©cnica (Muy importante en empresas)

Cuando usas Jenkins dentro de Docker con acceso al host: `Jenkins` usa `Docker-outside-of-Docker` (DooD)

Significa:

- `Jenkins` no tiene su propio `Docker Engine`.
- Usa el `CLI Docker` instalado dentro del contenedor.
- Se conecta al `Docker` del host mediante el socket: `/var/run/docker.sock`.

Esto permite:

- Construir imÃ¡genes
- Ejecutar contenedores
- Parar/limpiar contenedores
- Usar Docker Compose

ï¸âš ï¸ Riesgos reales a considerar

- Cualquier proceso dentro del contenedor Jenkins tiene permisos de root en el host.
- Las empresas suelen aislar los agentes con:
    - Agentes Kubernetes
    - Jenkins agents con privilegios mÃ­nimos
    - Containers sin acceso al socket Docker

### ğŸ“Œ ConclusiÃ³n

Este `Jenkinsfile`:

- Define un pipeline declarativo completo.
- Contiene las 4 etapas mÃ¡s comunes en empresas: `Build` â†’ `Test` â†’ `Build Docker` â†’ `Deploy`.
- EstÃ¡ preparado para integrarse con herramientas reales como `SonarQube`, `Nexus`, `Docker Registry`, etc.
- EstÃ¡ escrito siguiendo mejores prÃ¡cticas modernas de CI/CD.

## ğŸš€ Primer Pipeline en Jenkins

En esta secciÃ³n crearemos nuestro primer `Pipeline Declarativo` en Jenkins y analizaremos cÃ³mo ejecutar mÃºltiples pasos,
visualizar resultados e instalar herramientas adicionales para entender mejor la ejecuciÃ³n del pipeline.

### ğŸ”Œ Verificando la instalaciÃ³n del plugin Pipeline

El contenedor oficial de Jenkins incluye por defecto el `Pipeline Plugin`, tambiÃ©n conocido como:

- Workflow API
- Declarative Pipeline
- Scripted Pipeline Runtime

Para verificar que estÃ¡ presente, ingresamos a: `Manage Jenkins â†’ Plugins â†’ Installed plugins`. Como se observa en la
imagen, el plugin Pipeline ya estÃ¡ instalado.

![01.png](assets/section-15/01.png)

En empresas, Jenkins casi siempre se despliega con los plugins esenciales ya preinstalados mediante:

- Jenkins Configuration as Code (JCasC)
- ImÃ¡genes Docker personalizadas
- Scripts Groovy de inicializaciÃ³n

Esto garantiza consistencia entre entornos.

### ğŸ†• Creando nuestro primer Pipeline

Creamos una `nueva tarea (job)` llamado `primer-pripeline` y, en lugar de seleccionar â€œFreestyle Projectâ€, elegimos
`Pipeline`, que permite definir automatizaciones completas usando cÃ³digo.

![02.png](assets/section-15/02.png)

- Los pipelines deben escribirse siempre como cÃ³digo para ser versionados.
- Los Freestyle Jobs estÃ¡n prÃ¡cticamente obsoletos para CI/CD moderno.

### âœï¸ Definiendo el Pipeline Script

Al ingresar al nuevo job `primer-pripeline`, veremos opciones similares a las de un job clÃ¡sico, salvo que:

- Ya no existen `Build Steps`.
- En su lugar aparece la secciÃ³n `Pipeline`.

Esta secciÃ³n permite dos modos principales:

- 1ï¸âƒ£ `Pipeline Script`. Escribir el pipeline directamente en el editor de Jenkins (modo recomendado solo para pruebas
  o demos).
- 2ï¸âƒ£ `Pipeline Script from SCM`. Usar un repositorio Git para cargar un `Jenkinsfile` real. Este es el mÃ©todo estÃ¡ndar
  en empresas.

Por ahora usaremos el modo manual (`Pipeline Script`).

### ğŸ§± Primer Pipeline simple (solo imprime mensajes)

````groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                echo 'Compilando la aplicaciÃ³n...'
            }
        }
        stage('Test') {
            steps {
                echo 'Ejecutando pruebas...'
            }
        }
        stage('Deploy') {
            steps {
                echo 'Desplegando la aplicaciÃ³n...'
            }
        }
    }
}
````

En la interfaz se verÃ¡ asÃ­:

![03.png](assets/section-15/03.png)

### â–¶ï¸ Ejecutando el Pipeline

Al pulsar `Construir ahora`, Jenkins procesarÃ¡ las etapas secuencialmente.

![04.png](assets/section-15/04.png)

### ğŸ“œ Revisando el Console Output

En el log de la ejecuciÃ³n podemos ver:

- El pipeline fue asignado a un ejecutor.
- Cada stage se ejecutÃ³ correctamente.
- Todos los mensajes `echo` se imprimieron.

![05.png](assets/section-15/05.png)

ğŸ’¡ `Importante`. El `Console Output` es la herramienta principal para depurar errores en `Jenkins`.

## ğŸ”„ Ejecutando mÃºltiples pasos en una etapa

`Jenkins Pipeline` permite ejecutar mÃºltiples comandos dentro del bloque `steps`. Cada `step` representa una acciÃ³n
individual.

DocumentaciÃ³n oficial: https://www.jenkins.io/doc/pipeline/tour/running-multiple-steps/

### ğŸ“Œ Conceptos clave

- Un `step` = Un comando o acciÃ³n individual.
- Si un step falla â†’ âŒ el pipeline se detiene.
- Si todos los steps completan â†’ âœ”ï¸ la etapa es exitosa.

### ğŸ§ Uso del paso `sh` en Linux / BSD / macOS

En sistemas tipo Unix, usamos `sh` para ejecutar comandos de shell:

````groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'echo "Compilando la aplicaciÃ³n..."'
                sh '''
                    echo "Los pasos de shell multilÃ­nea tambiÃ©n funcionan"
                    ls -lah
                    pwd
                '''
            }
        }
        stage('Test') {
            steps {
                echo 'Ejecutando pruebas...'
            }
        }
        stage('Deploy') {
            steps {
                echo 'Desplegando la aplicaciÃ³n...'
            }
        }
    }
}
````

En la siguiente imagen se muestra cÃ³mo quedarÃ­a el cÃ³digo anterior.

![06.png](assets/section-15/06.png)

Guardamos el nuevo pipeline con los mÃºltiples pasos agregados y procedemos a construir la aplicaciÃ³n. Vemos que
la construcciÃ³n se realizÃ³ exitosamente.

![07.png](assets/section-15/07.png)

Ahora, si revisamos el log generado por la ejecuciÃ³n `#4` vemos que los mÃºltiples pasos se han ejecutado sin problemas.
Eso permitiÃ³ que las siguientes etapas continÃºen su ejecuciÃ³n.

````bash
Started by user System Admin
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/jenkins_home/workspace/primer-pipeline
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Build)
[Pipeline] sh
+ echo Compilando la aplicaciÃ³n...
Compilando la aplicaciÃ³n...
[Pipeline] sh
+ echo Los pasos de shell multilÃ­nea tambiÃ©n funcionan
Los pasos de shell multilÃ­nea tambiÃ©n funcionan
+ ls -lah
total 8.0K
drwxr-xr-x  2 jenkins jenkins 4.0K Nov 28 18:15 .
drwxr-xr-x 17 jenkins jenkins 4.0K Nov 28 18:15 ..
+ pwd
/var/jenkins_home/workspace/primer-pipeline
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Test)
[Pipeline] echo
Ejecutando pruebas...
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Deploy)
[Pipeline] echo
Desplegando la aplicaciÃ³n...
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS 
````

## ğŸ“Š InstalaciÃ³n del plugin Pipeline Stage View

Este plugin agrega una interfaz visual muy Ãºtil para ver:

- Etapas del pipeline
- DuraciÃ³n por etapa
- Estado de cada ejecuciÃ³n
- Paralelismo (si aplica)

Pasos para instalar:

![08.png](assets/section-15/08.png)

Habiendo instalado el plugin y reiniciado Jenkins (si se requiere reinicio manual ir a la siguiente direcciÃ³n
`http://localhost:8080/safeRestart`), nos vamos a nuestro job `primer-pipeline` y vemos que ahora las ejecuciones
se muestran grÃ¡ficamente, incluso se muestran las etapas: Build | Test | Deploy y en cada fila el nÃºmero de ejecuciÃ³n
realizada al job. Debajo de cada etapa se muestra el fondo en color verde indicando que esa etapa se realizÃ³ con Ã©xito.

- ğŸŸ© Verde = Ã©xito
- ğŸŸ¥ Rojo = fallo
- ğŸŸ¨ Amarillo = inestable (usualmente por pruebas fallidas)

![09.png](assets/section-15/09.png)

### ğŸ§  Diferencias entre versiones de Jenkins

El instructor no necesitÃ³ instalarlo porque:

- Algunas versiones antiguas (LTS previas) venÃ­an con este plugin preinstalado.
- En tu caso, la versiÃ³n moderna del contenedor no incluye plugins adicionales para mantener la imagen mÃ¡s ligera.
