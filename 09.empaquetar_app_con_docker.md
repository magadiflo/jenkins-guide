# ğŸš€ SecciÃ³n 9: Empaquetar una AplicaciÃ³n Spring Boot con Docker

En esta secciÃ³n realizaremos lo que en empresas se conoce como:
**â€œConstrucciÃ³n y empaquetado de una aplicaciÃ³n Java + Spring Boot en una imagen Docker lista para despliegueâ€**.

Aunque en el curso el tutor utiliza una app Node.js, aquÃ­ trabajaremos directamente con nuestro stack
`Java/Spring Boot`, lo cual es mÃ¡s relevante para nuestra lÃ­nea profesional en `CI/CD`.

---

## ğŸ—‚ï¸ Crear repositorio en GitHub con aplicaciÃ³n Spring Boot

Para esta secciÃ³n construiremos una aplicaciÃ³n sencilla de Spring Boot que cumpla con:

- ğŸ§© Un endpoint REST bÃ¡sico.
- ğŸ³ Un `Dockerfile` funcional siguiendo prÃ¡cticas de empresas.
- â˜ï¸ CÃ³digo almacenado en GitHub: https://github.com/magadiflo/spring-boot-jenkins-app

ğŸ“¸ Estructura del repositorio:

![01.png](assets/section-09/01.png)

A continuaciÃ³n mostramos la construcciÃ³n del proyecto base.

### ğŸ“¦ Dependencias del proyecto (Spring Initializr)

El proyecto se creÃ³ usando
[Spring initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.7&packaging=jar&configurationFileFormat=yaml&jvmVersion=21&groupId=dev.magadiflo&artifactId=spring-boot-jenkins-app&name=spring-boot-jenkins-app&description=Demo%20project%20for%20Spring%20Boot&packageName=dev.magadiflo.app&dependencies=web,lombok,actuator)
con las siguientes dependencias:

````xml
<!--Spring Boot 3.5.7-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

### ğŸ› ï¸ ConfiguraciÃ³n del application.yml

````yml
server:
  port: 8081
  error:
    include-message: always

spring:
  application:
    name: spring-boot-jenkins-app
````

ğŸ’¡ Nota:
> En el mundo real, los puertos rara vez se fijan en el cÃ³digo; se parametrizan mediante variables de entorno.
> Pero para este ejemplo estÃ¡ bien dejarlo `hardcodeado` en `8081`.

### ğŸŒ Endpoint REST bÃ¡sico

````java

@RestController
@RequestMapping(path = "/api/v1/greetings")
public class HelloController {
    @GetMapping
    public ResponseEntity<Map<String, Object>> hello() {
        var response = new HashMap<String, Object>();
        response.put("message", "Hola desde Spring Boot + Jenkins!");
        response.put("timestamp", LocalDateTime.now());
        response.put("version", "1.0.0");
        return ResponseEntity.ok(response);
    }
}
````

### ğŸ” VerificaciÃ³n del funcionamiento

âœ”ï¸ Endpoint propio

````bash
$ curl -v http://localhost:8081/api/v1/greetings | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 19 Nov 2025 16:21:45 GMT
<
{
  "message": "Hola desde Spring Boot + Jenkins!",
  "version": "1.0.0",
  "timestamp": "2025-11-19T11:21:45.1053065"
}
````

âœ”ï¸ Endpoint Actuator

````bash
$ curl -v http://localhost:8081/actuator/health | jq
>
< HTTP/1.1 200
< Content-Type: application/vnd.spring-boot.actuator.v3+json
< Transfer-Encoding: chunked
< Date: Wed, 19 Nov 2025 16:22:18 GMT
<
{
  "status": "UP"
}
````

### ğŸ³ Creando el Dockerfile â€” Multi-Stage Build (PrÃ¡ctica de Empresa)

Ubicado en raÃ­z del proyecto (junto al `pom.xml`):

````Dockerfile
# Stage 1: Build con Maven 3.9.11 + Java 21
FROM maven:3.9.11-eclipse-temurin-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

# Stage 2: Runtime con JRE 21
FROM eclipse-temurin:21-jre-alpine AS runtime
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8081

# Usar ENTRYPOINT para inmutabilidad
ENTRYPOINT ["java", "-jar", "app.jar"] 
````

ğŸ“Œ Â¿Por quÃ© este Dockerfile? (ExplicaciÃ³n Realista)

| CaracterÃ­stica                                | Beneficio                                              |
|-----------------------------------------------|--------------------------------------------------------|
| ğŸ—ï¸ **Multi-stage build**                     | Reduce tamaÃ±o y mejora seguridad.                      |
| âš™ï¸ **Maven + JDK solo para la fase de build** | No expones herramientas innecesarias en producciÃ³n.    |
| ğŸ”¥ **Imagen final minimalista (JRE Alpine)**  | menos superficie de ataque + menos tiempo de arranque. |
| ğŸ“ **COPY selectivo**                         | Copia solo el JAR final â†’ imagen limpia.               |
| ğŸ› **ENTRYPOINT**                             | Define comando inmutable para ejecuciÃ³n estÃ¡ndar.      |
| ğŸ“¤ **Expose 8081**                            | Documenta el puerto usado por la app (Spring Boot).    |

### ğŸ“¦ Lista final de entregables de esta secciÃ³n

- âœ”ï¸ Proyecto Spring Boot funcional
- âœ”ï¸ Repositorio GitHub correctamente organizado
- âœ”ï¸ Endpoint REST y verificaciÃ³n
- âœ”ï¸ Dockerfile profesional estilo empresa
- âœ”ï¸ Imagen lista para ser construida por Jenkins en la siguiente secciÃ³n

## ğŸš€ InstalaciÃ³n del Plugin: CloudBees Docker Build and Publish

Para habilitar que `Jenkins` pueda construir y publicar imÃ¡genes Docker directamente desde un job, instalaremos
el plugin `CloudBees Docker Build and Publish`.

### ğŸ› ï¸ Â¿QuÃ© es el Plugin `CloudBees Docker Build and Publish`?

El `CloudBees Docker Build and Publish` Plugin para Jenkins es una extensiÃ³n que proporciona pasos de pipeline
(o `build steps` para `jobs de estilo libre`) para interactuar directamente con la tecnologÃ­a `Docker`.

Su propÃ³sito fundamental es permitir que un `job` de `Jenkins`:

1. `Construya (Build)` una imagen de `Docker` a partir de un `Dockerfile`.
2. `Etiquete (Tag)` esa imagen con la convenciÃ³n de nombres y versiones deseada.
3. `Publique (Push)` la imagen resultante a un registro de Docker, como `Docker Hub` (en nuestro caso), un registro
   privado o cualquier otro compatible con la API de Docker.

### ğŸ“¥ Pasos para instalar el plugin

1. âš™ï¸ Ve a `Manage Jenkins` â†’ `Plugins`
2. ğŸ“¦ Ingresa a la pestaÃ±a `Available plugins`
3. ğŸ” Busca: `CloudBees Docker Build and Publish`
4. â˜‘ï¸ SelecciÃ³nalo e instÃ¡lalo

![02.png](assets/section-09/02.png)

5. ğŸ”„ Finalmente, marcamos en `Reiniciar Jenkins...`.

![03.png](assets/section-09/03.png)

## ğŸš€ Crear una nueva tarea (Job) en Jenkins

En esta lecciÃ³n crearemos un `job freestyle` que nos permitirÃ¡ integrar el repositorio de `GitHub`, construir nuestra
imagen Docker y posteriormente publicarla en `Docker Hub`.

ğŸ’¡ Nota profesional
> Aunque en empresas se suele preferir `Pipelines Declarativos` (`Jenkinsfile`) por su mantenibilidad, control de
> versiones y auditorÃ­a, aprender con un `Freestyle Job` es un excelente primer paso para entender la automatizaciÃ³n
> antes de pasar a pipelines como cÃ³digo.

### ğŸ§± Pasos para crear un nuevo Job en Jenkins

1. En el panel principal de Jenkins, haz clic en `Nueva tarea` (New Item).
2. En el campo de nombre, introduce: `spring-boot-docker-hub`.
    ````
    ğŸ“Œ Se recomienda usar nombres descriptivos, claros y en minÃºsculas, siguiendo el estÃ¡ndar `kebab-case`. 
    ````
3. Selecciona el tipo de proyecto: `Proyecto de estilo libre` (Freestyle project).
4. Haz clic en `OK` para crear el job.

![04.png](assets/section-09/04.png)

## ğŸ”— Configurar el origen del cÃ³digo fuente (GitHub)

En este paso vincularemos nuestro Job de Jenkins con el repositorio donde vive nuestra aplicaciÃ³n Spring Boot. Esto
permitirÃ¡ que `Jenkins` `obtenga el cÃ³digo fuente directamente desde GitHub` en cada ejecuciÃ³n del Job.

### ğŸ§© Pasos para configurar Git como origen del cÃ³digo

En la secciÃ³n `Configurar el origen del cÃ³digo fuente`:

1. Selecciona `Git`.
2. **Repository URL**: `https://github.com/magadiflo/spring-boot-jenkins-app.git`
3. **Branch**: `*/main` o `*/master` (segÃºn tu rama principal)
4. Credenciales: Si es repo pÃºblico, dÃ©jalo en `- none -`. Si es privado, agrega credenciales de GitHub.

![05.png](assets/section-09/05.png)

## ğŸ³ Configurar Build: Docker Build and Publish

En esta secciÃ³n crearemos el paso de build que permitirÃ¡ a Jenkins:

- Construir nuestra `imagen Docker` a partir del `Dockerfile`.
- Etiquetarla correctamente.
- Publicarla en `Docker Hub`.

Todo esto utilizando el plugin `CloudBees Docker Build and Publish`.

### ğŸ§± Agregar el Build Step

1. Clic en `AÃ±adir un nuevo paso`
2. Selecciona `Docker Build and Publish`

Esto habilita un formulario con la configuraciÃ³n necesaria para generar y publicar la imagen.

### âš™ï¸ ConfiguraciÃ³n del paso Docker Build and Publish

| Campo                    | Valor                               | DescripciÃ³n                                                                 |
|--------------------------|-------------------------------------|-----------------------------------------------------------------------------|
| **Repository Name**      | `magadiflo/spring-boot-jenkins-app` | Nombre completo en Docker Hub (`tu-usuario/nombre-imagen`)                  |
| **Tag**                  | `${BUILD_NUMBER}` o `latest`        | Etiqueta de la imagen. `${BUILD_NUMBER}` usa el nÃºmero de build de Jenkins. |
| **Docker registry URL**  | (vacÃ­o)                             | Dejar vacÃ­o usa Docker Hub por defecto                                      |
| **Registry credentials** | (Crear nueva)                       | Credenciales de Docker Hub                                                  |

### ğŸ” Crear credenciales para Docker Hub

1. Clic en `+ Add` â†’ `Jenkins`
2. **Kind**: Username with password
3. **Username**: Tu usuario de Docker Hub. Puede ser correo o username real. Se recomienda username (ej: `magadiflo`)
4. **Password**: Tu contraseÃ±a de Docker Hub (o Access Token recomendado)
5. **Description**: `Credenciales - Docker Hub`
6. Clic en **Add**
7. Selecciona la credencial reciÃ©n creada en el `dropdown`

### ğŸ·ï¸ ConfiguraciÃ³n de Tags (opcional pero recomendado)

Puedes utilizar uno o varios tags para mejorar el versionado de tus imÃ¡genes.

| Tag                   | Resultado                           | Uso                         |
|-----------------------|-------------------------------------|-----------------------------|
| `latest`              | `magadiflo/spring-boot-demo:latest` | Ãšltima versiÃ³n (default)    |
| `${BUILD_NUMBER}`     | `magadiflo/spring-boot-demo:15`     | VersiÃ³n por nÃºmero de build |
| `1.0.${BUILD_NUMBER}` | `magadiflo/spring-boot-demo:1.0.15` | Versionado semÃ¡ntico        |
| `v1.0.0`              | `magadiflo/spring-boot-demo:v1.0.0` | VersiÃ³n fija                |

### â­ RecomendaciÃ³n profesional

Usa dos tags simultÃ¡neamente:

````bash
Tag: latest,${BUILD_NUMBER} 
````

Esto te da:

- `latest` â†’ siempre apunta a la versiÃ³n mÃ¡s reciente.
- `${BUILD_NUMBER}` â†’ te permite rastrear quÃ© build generÃ³ quÃ© imagen.

Ideal para pipelines reales en empresas.

![06.png](assets/section-09/06.png)

## ğŸ³ Crear Repositorio en Docker Hub

En la lecciÃ³n anterior configuramos en `Jenkins` el nombre del repositorio donde se publicarÃ¡ nuestra imagen Docker:
`magadiflo/spring-boot-jenkins-app`.

Sin embargo, ese repositorio aÃºn no existe en `Docker Hub`, asÃ­ que ahora lo crearemos.

### ğŸ§­ 1. Crear repositorio en Docker Hub

1. Ingresa a: https://hub.docker.com/
2. Ve al menÃº superior y selecciona: `Repositories` â†’ `Create Repository`
3. Completa los siguientes campos:

| Campo               | Valor                     | DescripciÃ³n                                              |
|---------------------|---------------------------|----------------------------------------------------------|
| **Repository Name** | `spring-boot-jenkins-app` | Solo el nombre, sin el usuario                           |
| **Visibility**      | `Public` o `Private`      | Para CI/CD, pÃºblico es mÃ¡s simple si no manejas secretos |
| **Description**     | DescripciÃ³n opcional      | Ayuda a identificar la imagen                            |

![07.png](assets/section-09/07.png)

ğŸ“Œ El nombre completo final queda asÃ­:

````bash
magadiflo/spring-boot-jenkins-app
````

### ğŸ“‚ 2. Repositorio creado (vacÃ­o)

Una vez creado, verÃ¡s tu repositorio en Docker Hub, inicialmente sin imÃ¡genes.

âš ï¸ Esto es completamente normal â€” la imagen se publicarÃ¡ reciÃ©n cuando ejecutemos el job de Jenkins.

![08.png](assets/section-09/08.png)

## ğŸš§ Primera ConstrucciÃ³n del Job (con fallo esperado)

DespuÃ©s de configurar nuestro Build Step (`Docker Build and Publish`) y guardar los cambios, procedemos a ejecutar
nuestro pipeline por primera vez.

1. Ir al job `spring-boot-docker-hub`.
2. Hacer clic en `Construir Ahora` (Build Now).

![09.png](assets/section-09/09.png)

Tras unos segundos, veremos que el build aparece en rojo âŒ indicando un fallo. Para diagnosticarlo, abrimos el
`Console Output` del build fallido:

![10.png](assets/section-09/10.png)

### ğŸ§ª AnÃ¡lisis del error en la consola

La mayor parte del proceso se ejecuta correctamente; la construcciÃ³n de la imagen Docker finaliza sin inconvenientes:

````bash
...
...
#13 [runtime 3/3] COPY --from=build /app/target/*.jar app.jar
#13 CACHED

#14 exporting to image
#14 exporting layers done
#14 writing image sha256:e2731189f769d7e32eaa555a409b5e6d9ebc4f2c99f56b75ed3927f6c6de9815 done
#14 naming to docker.io/magadiflo/spring-boot-jenkins-app:latest done
#14 DONE 0.0s
... 
````

El error se produce durante el `push a Docker Hub`:

````bash
...
...
[spring-boot-docker-hub] $ docker push magadiflo/spring-boot-jenkins-app:latest
The push refers to repository [docker.io/magadiflo/spring-boot-jenkins-app]
72a0045afbf5: Preparing
a339506eec50: Preparing
8bbd26e5bb80: Preparing
bc7091554844: Preparing
c6974a5a45a3: Preparing
409a60df3c0b: Preparing
256f393e029f: Preparing
409a60df3c0b: Waiting
256f393e029f: Waiting
denied: requested access to the resource is denied
Build step 'Docker Build and Publish' marked build as failure
Finished: FAILURE
````

### â— Â¿QuÃ© significa este error?

El mensaje:

> denied: requested access to the resource is denied

Indica que `Docker no tiene permisos para subir la imagen` a `Docker Hub` porque `Jenkins` no estÃ¡ autenticado en
`Docker Hub` dentro del contenedor donde estÃ¡ ejecutÃ¡ndose.

![11.png](assets/section-09/11.png)

### ğŸ› ï¸ SoluciÃ³n al error: Autenticar Jenkins en Docker Hub (dentro del contenedor)

Este problema es frecuente cuando se trabaja con `Jenkins` dentro de `Docker`: el contenedor de `Jenkins` tiene
`Docker CLI` instalado, pero no estÃ¡ logueado en `Docker Hub`.

Para solucionarlo:

1. Ingresar al contenedor de Jenkins.
2. Autenticar Docker Hub desde dentro del contenedor.
    - Al ejecutar el comando `docker login -u magadiflo`, el CLI nos pedirÃ¡ la contraseÃ±a o mejor aÃºn, un Personal
      Access Token (PAT).
    - Ingresamos nuestra contraseÃ±a o token.
3. Si la autenticaciÃ³n fue exitosa veremos el mensaje `Login Succeeded`.
4. Para validar que estamos autenticados podemos ejecutar este comando `docker info | grep Usernam` que nos mostrarÃ¡ el
   usuario logueado.

````bash
$ docker container exec -it c-jenkins /bin/sh
$ docker login -u magadiflo

i Info â†’ A Personal Access Token (PAT) can be used instead.
         To create a PAT, visit https://app.docker.com/settings


Password:

WARNING! Your credentials are stored unencrypted in '/var/jenkins_home/.docker/config.json'.
Configure a credential helper to remove this warning. See
https://docs.docker.com/go/credential-store/

Login Succeeded
$ docker info | grep Username
 Username: magadiflo
WARNING: No blkio throttle.read_bps_device support
WARNING: No blkio throttle.write_bps_device support
WARNING: No blkio throttle.read_iops_device support
WARNING: No blkio throttle.write_iops_device support
$ 
````

### ğŸ“ Â¿DÃ³nde guarda Docker las credenciales?

Guarda las credenciales en `/var/jenkins_home/.docker/config.json`. Este archivo queda disponible para futuros builds,
por lo que **ya no tendrÃ¡s que loguearte otra vez**.

### âœ… Resultado

â¡ï¸ Con Jenkins ya autenticado dentro del contenedor, la prÃ³xima ejecuciÃ³n del job subirÃ¡ la imagen correctamente a
Docker Hub.

## ğŸš€ Segunda ConstrucciÃ³n del Job (EjecuciÃ³n Exitosa)

DespuÃ©s de autenticarnos correctamente en Docker Hub dentro del contenedor de Jenkins, ya estamos listos para ejecutar
nuevamente nuestro job `spring-boot-docker-hub`.

![12.png](assets/section-09/12.png)

### ğŸ‰ Resultado: Build Exitoso

Esta vez el proceso finaliza sin errores, indicando que Jenkins pudo:

- Construir la imagen Docker
- Etiquetarla
- Autenticarse en Docker Hub
- Subirla correctamente

![13.png](assets/section-09/13.png)

### ğŸ” VerificaciÃ³n: Console Output

Si revisamos el `Console Output` de esta segunda ejecuciÃ³n, veremos que todo ha funcionado correctamente. Ahora sÃ­
aparece el bloque final donde se realiza exitosamente el push hacia Docker Hub:

![14.png](assets/section-09/14.png)

