# Sección 9: Empaquetar App con Docker

En esta sección estaremos trabajando con una aplicación de Spring Boot, dado que es el stack que nos interesa.
Sin embargo, en esta sección del curso el tutor trabaja entorno a una aplicación de Node.js. Podría haberlo trabajado
también con Node.js, pero decidí trabajar con Spring Boot para poder practicar Jenkins con el stack que manejo.

---

## Crear repositorio en GitHub con app Spring Boot

En esta primera parte crearemos un proyecto Spring Boot simple con:

- Un endpoint REST básico.
- Un Dockerfile para construir la imagen.
- Proyecto subido a repositorio de GitHub:
  [spring-boot-jenkins-app](https://github.com/magadiflo/spring-boot-jenkins-app).

A continuación mostramos rápidamente la construcción del proyecto base para tenerlo documentado y saber qué es lo que
contiene el proyecto, aunque también podríamos ir al repositorio del mismo para verlo en detalle.

### Dependencias

El proyecto se creó desde
[Spring initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.7&packaging=jar&configurationFileFormat=yaml&jvmVersion=21&groupId=dev.magadiflo&artifactId=spring-boot-jenkins-app&name=spring-boot-jenkins-app&description=Demo%20project%20for%20Spring%20Boot&packageName=dev.magadiflo.app&dependencies=web,lombok,actuator)
con el siguiente nombre [spring-boot-jenkins-app](https://github.com/magadiflo/spring-boot-jenkins-app).

````xml
<!--Spring Boot 3.5.7-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

### Configurando application.yml

````yml
server:
  port: 8081
  error:
    include-message: always

spring:
  application:
    name: spring-boot-jenkins-app
````

### Endpoint REST básico

````java

@RestController
@RequestMapping(path = "/api/v1/greetings")
public class HelloController {
    @GetMapping
    public ResponseEntity<Map<String, Object>> hello() {
        var response = new HashMap<String, Object>();
        response.put("message", "Hola desde Spring Boot + Jenkins!");
        response.put("timestamp", LocalDateTime.now());
        response.put("version", "1.0.0");
        return ResponseEntity.ok(response);
    }
}
````

### Verificando funcionamiento de endpoints

El endpoint que nosotros creamos.

````bash
$ curl -v http://localhost:8081/api/v1/greetings | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 19 Nov 2025 16:21:45 GMT
<
{
  "message": "Hola desde Spring Boot + Jenkins!",
  "version": "1.0.0",
  "timestamp": "2025-11-19T11:21:45.1053065"
}
````

El endpoint que nos proporciona por defecto Actuator.

````bash
$ curl -v http://localhost:8081/actuator/health | jq
>
< HTTP/1.1 200
< Content-Type: application/vnd.spring-boot.actuator.v3+json
< Transfer-Encoding: chunked
< Date: Wed, 19 Nov 2025 16:22:18 GMT
<
{
  "status": "UP"
}
````

### Creando Dockerfile para construir imagen

En la raíz de nuestra aplicación `spring-boot-jenkins-app`, al mismo nivel del `pom.xml` creamos el archivo
`Dockerfile` con las siguientes configuraciones.

````Dockerfile
# Stage 1: Build con Maven 3.9.11 + Java 21
FROM maven:3.9.11-eclipse-temurin-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

# Stage 2: Runtime con JRE 21
FROM eclipse-temurin:21-jre-alpine AS runtime
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8081

# Usar ENTRYPOINT para inmutabilidad
ENTRYPOINT ["java", "-jar", "app.jar"] 
````

¿Por qué este Dockerfile?

- ✅ **Multi-stage build**: Reduce tamaño de imagen final (de ~800MB a ~250MB)
- ✅ **Stage 1 (build)**: Usa Maven para compilar y generar el `.jar`
- ✅ **Stage 2 (runtime)**: Solo incluye JRE y el `.jar` final
- ✅ **Alpine**: Imagen base ligera
- ✅ **Expone puerto 8081**: Puerto configurado en Spring Boot (`server.port`).
