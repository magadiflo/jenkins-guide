# üöÄ Secci√≥n 9: Empaquetar una Aplicaci√≥n Spring Boot con Docker

En esta secci√≥n realizaremos lo que en empresas se conoce como:
**‚ÄúConstrucci√≥n y empaquetado de una aplicaci√≥n Java + Spring Boot en una imagen Docker lista para despliegue‚Äù**.

Aunque en el curso el tutor utiliza una app Node.js, aqu√≠ trabajaremos directamente con nuestro stack
`Java/Spring Boot`, lo cual es m√°s relevante para nuestra l√≠nea profesional en `CI/CD`.

---

## üóÇÔ∏è Crear repositorio en GitHub con aplicaci√≥n Spring Boot

Para esta secci√≥n construiremos una aplicaci√≥n sencilla de Spring Boot que cumpla con:

- üß© Un endpoint REST b√°sico.
- üê≥ Un `Dockerfile` funcional siguiendo pr√°cticas de empresas.
- ‚òÅÔ∏è C√≥digo almacenado en GitHub: https://github.com/magadiflo/spring-boot-jenkins-app

üì∏ Estructura del repositorio:

![01.png](assets/section-09/01.png)

A continuaci√≥n mostramos la construcci√≥n del proyecto base.

### üì¶ Dependencias del proyecto (Spring Initializr)

El proyecto se cre√≥ usando
[Spring initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.7&packaging=jar&configurationFileFormat=yaml&jvmVersion=21&groupId=dev.magadiflo&artifactId=spring-boot-jenkins-app&name=spring-boot-jenkins-app&description=Demo%20project%20for%20Spring%20Boot&packageName=dev.magadiflo.app&dependencies=web,lombok,actuator)
con las siguientes dependencias:

````xml
<!--Spring Boot 3.5.7-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

### üõ†Ô∏è Configuraci√≥n del application.yml

````yml
server:
  port: 8081
  error:
    include-message: always

spring:
  application:
    name: spring-boot-jenkins-app
````

üí° Nota:
> En el mundo real, los puertos rara vez se fijan en el c√≥digo; se parametrizan mediante variables de entorno.
> Pero para este ejemplo est√° bien dejarlo `hardcodeado` en `8081`.

### üåê Endpoint REST b√°sico

````java

@RestController
@RequestMapping(path = "/api/v1/greetings")
public class HelloController {
    @GetMapping
    public ResponseEntity<Map<String, Object>> hello() {
        var response = new HashMap<String, Object>();
        response.put("message", "Hola desde Spring Boot + Jenkins!");
        response.put("timestamp", LocalDateTime.now());
        response.put("version", "1.0.0");
        return ResponseEntity.ok(response);
    }
}
````

### üîé Verificaci√≥n del funcionamiento

‚úîÔ∏è Endpoint propio

````bash
$ curl -v http://localhost:8081/api/v1/greetings | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 19 Nov 2025 16:21:45 GMT
<
{
  "message": "Hola desde Spring Boot + Jenkins!",
  "version": "1.0.0",
  "timestamp": "2025-11-19T11:21:45.1053065"
}
````

‚úîÔ∏è Endpoint Actuator

````bash
$ curl -v http://localhost:8081/actuator/health | jq
>
< HTTP/1.1 200
< Content-Type: application/vnd.spring-boot.actuator.v3+json
< Transfer-Encoding: chunked
< Date: Wed, 19 Nov 2025 16:22:18 GMT
<
{
  "status": "UP"
}
````

### üê≥ Creando el Dockerfile ‚Äî Multi-Stage Build (Pr√°ctica de Empresa)

Ubicado en ra√≠z del proyecto (junto al `pom.xml`):

````Dockerfile
# Stage 1: Build con Maven 3.9.11 + Java 21
FROM maven:3.9.11-eclipse-temurin-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

# Stage 2: Runtime con JRE 21
FROM eclipse-temurin:21-jre-alpine AS runtime
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8081

# Usar ENTRYPOINT para inmutabilidad
ENTRYPOINT ["java", "-jar", "app.jar"] 
````

üìå ¬øPor qu√© este Dockerfile? (Explicaci√≥n Realista)

| Caracter√≠stica                                | Beneficio                                              |
|-----------------------------------------------|--------------------------------------------------------|
| üèóÔ∏è **Multi-stage build**                     | Reduce tama√±o y mejora seguridad.                      |
| ‚öôÔ∏è **Maven + JDK solo para la fase de build** | No expones herramientas innecesarias en producci√≥n.    |
| üî• **Imagen final minimalista (JRE Alpine)**  | menos superficie de ataque + menos tiempo de arranque. |
| üìÅ **COPY selectivo**                         | Copia solo el JAR final ‚Üí imagen limpia.               |
| üõû **ENTRYPOINT**                             | Define comando inmutable para ejecuci√≥n est√°ndar.      |
| üì§ **Expose 8081**                            | Documenta el puerto usado por la app (Spring Boot).    |

### üì¶ Lista final de entregables de esta secci√≥n

- ‚úîÔ∏è Proyecto Spring Boot funcional
- ‚úîÔ∏è Repositorio GitHub correctamente organizado
- ‚úîÔ∏è Endpoint REST y verificaci√≥n
- ‚úîÔ∏è Dockerfile profesional estilo empresa
- ‚úîÔ∏è Imagen lista para ser construida por Jenkins en la siguiente secci√≥n

## üöÄ Instalaci√≥n del Plugin: CloudBees Docker Build and Publish

Para habilitar que `Jenkins` pueda construir y publicar im√°genes Docker directamente desde un job, instalaremos
el plugin `CloudBees Docker Build and Publish`.

### üõ†Ô∏è ¬øQu√© es el Plugin `CloudBees Docker Build and Publish`?

El `CloudBees Docker Build and Publish` Plugin para Jenkins es una extensi√≥n que proporciona pasos de pipeline
(o `build steps` para `jobs de estilo libre`) para interactuar directamente con la tecnolog√≠a `Docker`.

Su prop√≥sito fundamental es permitir que un `job` de `Jenkins`:

1. `Construya (Build)` una imagen de `Docker` a partir de un `Dockerfile`.
2. `Etiquete (Tag)` esa imagen con la convenci√≥n de nombres y versiones deseada.
3. `Publique (Push)` la imagen resultante a un registro de Docker, como `Docker Hub` (en nuestro caso), un registro
   privado o cualquier otro compatible con la API de Docker.

### üì• Pasos para instalar el plugin

1. ‚öôÔ∏è Ve a `Manage Jenkins` ‚Üí `Plugins`
2. üì¶ Ingresa a la pesta√±a `Available plugins`
3. üîç Busca: `CloudBees Docker Build and Publish`
4. ‚òëÔ∏è Selecci√≥nalo e inst√°lalo

![02.png](assets/section-09/02.png)

5. üîÑ Finalmente, marcamos en `Reiniciar Jenkins...`.

![03.png](assets/section-09/03.png)

## üöÄ Crear una nueva tarea (Job) en Jenkins

En esta lecci√≥n crearemos un `job freestyle` que nos permitir√° integrar el repositorio de `GitHub`, construir nuestra
imagen Docker y posteriormente publicarla en `Docker Hub`.

üí° Nota profesional
> Aunque en empresas se suele preferir `Pipelines Declarativos` (`Jenkinsfile`) por su mantenibilidad, control de
> versiones y auditor√≠a, aprender con un `Freestyle Job` es un excelente primer paso para entender la automatizaci√≥n
> antes de pasar a pipelines como c√≥digo.

### üß± Pasos para crear un nuevo Job en Jenkins

1. En el panel principal de Jenkins, haz clic en `Nueva tarea` (New Item).
2. En el campo de nombre, introduce: `spring-boot-docker-hub`.
    ````
    üìå Se recomienda usar nombres descriptivos, claros y en min√∫sculas, siguiendo el est√°ndar `kebab-case`. 
    ````
3. Selecciona el tipo de proyecto: `Proyecto de estilo libre` (Freestyle project).
4. Haz clic en `OK` para crear el job.

![04.png](assets/section-09/04.png)

## üîó Configurar el origen del c√≥digo fuente (GitHub)

En este paso vincularemos nuestro Job de Jenkins con el repositorio donde vive nuestra aplicaci√≥n Spring Boot. Esto
permitir√° que `Jenkins` `obtenga el c√≥digo fuente directamente desde GitHub` en cada ejecuci√≥n del Job.

### üß© Pasos para configurar Git como origen del c√≥digo

En la secci√≥n `Configurar el origen del c√≥digo fuente`:

1. Selecciona `Git`.
2. **Repository URL**: `https://github.com/magadiflo/spring-boot-jenkins-app.git`
3. **Branch**: `*/main` o `*/master` (seg√∫n tu rama principal)
4. Credenciales: Si es repo p√∫blico, d√©jalo en `- none -`. Si es privado, agrega credenciales de GitHub.

![05.png](assets/section-09/05.png)

## üê≥ Configurar Build: Docker Build and Publish

En esta secci√≥n crearemos el paso de build que permitir√° a Jenkins:

- Construir nuestra `imagen Docker` a partir del `Dockerfile`.
- Etiquetarla correctamente.
- Publicarla en `Docker Hub`.

Todo esto utilizando el plugin `CloudBees Docker Build and Publish`.

### üß± Agregar el Build Step

1. Clic en `A√±adir un nuevo paso`
2. Selecciona `Docker Build and Publish`

Esto habilita un formulario con la configuraci√≥n necesaria para generar y publicar la imagen.

### ‚öôÔ∏è Configuraci√≥n del paso Docker Build and Publish

| Campo                    | Valor                               | Descripci√≥n                                                                 |
|--------------------------|-------------------------------------|-----------------------------------------------------------------------------|
| **Repository Name**      | `magadiflo/spring-boot-jenkins-app` | Nombre completo en Docker Hub (`tu-usuario/nombre-imagen`)                  |
| **Tag**                  | `${BUILD_NUMBER}` o `latest`        | Etiqueta de la imagen. `${BUILD_NUMBER}` usa el n√∫mero de build de Jenkins. |
| **Docker registry URL**  | (vac√≠o)                             | Dejar vac√≠o usa Docker Hub por defecto                                      |
| **Registry credentials** | (Crear nueva)                       | Credenciales de Docker Hub                                                  |

### üîê Crear credenciales para Docker Hub

1. Clic en `+ Add` ‚Üí `Jenkins`
2. **Kind**: Username with password
3. **Username**: Tu usuario de Docker Hub. Puede ser correo o username real. Se recomienda username (ej: `magadiflo`)
4. **Password**: Tu contrase√±a de Docker Hub (o Access Token recomendado)
5. **Description**: `Credenciales - Docker Hub`
6. Clic en **Add**
7. Selecciona la credencial reci√©n creada en el `dropdown`

### üè∑Ô∏è Configuraci√≥n de Tags (opcional pero recomendado)

Puedes utilizar uno o varios tags para mejorar el versionado de tus im√°genes.

| Tag                   | Resultado                           | Uso                         |
|-----------------------|-------------------------------------|-----------------------------|
| `latest`              | `magadiflo/spring-boot-demo:latest` | √öltima versi√≥n (default)    |
| `${BUILD_NUMBER}`     | `magadiflo/spring-boot-demo:15`     | Versi√≥n por n√∫mero de build |
| `1.0.${BUILD_NUMBER}` | `magadiflo/spring-boot-demo:1.0.15` | Versionado sem√°ntico        |
| `v1.0.0`              | `magadiflo/spring-boot-demo:v1.0.0` | Versi√≥n fija                |

### ‚≠ê Recomendaci√≥n profesional

Usa dos tags simult√°neamente:

````bash
Tag: latest,${BUILD_NUMBER} 
````

Esto te da:

- `latest` ‚Üí siempre apunta a la versi√≥n m√°s reciente.
- `${BUILD_NUMBER}` ‚Üí te permite rastrear qu√© build gener√≥ qu√© imagen.

Ideal para pipelines reales en empresas.

![06.png](assets/section-09/06.png)

## üê≥ Crear Repositorio en Docker Hub

En la lecci√≥n anterior configuramos en `Jenkins` el nombre del repositorio donde se publicar√° nuestra imagen Docker:
`magadiflo/spring-boot-jenkins-app`.

Sin embargo, ese repositorio a√∫n no existe en `Docker Hub`, as√≠ que ahora lo crearemos.

### üß≠ 1. Crear repositorio en Docker Hub

1. Ingresa a: https://hub.docker.com/
2. Ve al men√∫ superior y selecciona: `Repositories` ‚Üí `Create Repository`
3. Completa los siguientes campos:

| Campo               | Valor                     | Descripci√≥n                                              |
|---------------------|---------------------------|----------------------------------------------------------|
| **Repository Name** | `spring-boot-jenkins-app` | Solo el nombre, sin el usuario                           |
| **Visibility**      | `Public` o `Private`      | Para CI/CD, p√∫blico es m√°s simple si no manejas secretos |
| **Description**     | Descripci√≥n opcional      | Ayuda a identificar la imagen                            |

![07.png](assets/section-09/07.png)

üìå El nombre completo final queda as√≠:

````bash
magadiflo/spring-boot-jenkins-app
````

### üìÇ 2. Repositorio creado (vac√≠o)

Una vez creado, ver√°s tu repositorio en Docker Hub, inicialmente sin im√°genes.

‚ö†Ô∏è Esto es completamente normal ‚Äî la imagen se publicar√° reci√©n cuando ejecutemos el job de Jenkins.

![08.png](assets/section-09/08.png)

## üöß Primera Construcci√≥n del Job (con fallo esperado)

Despu√©s de configurar nuestro Build Step (`Docker Build and Publish`) y guardar los cambios, procedemos a ejecutar
nuestro pipeline por primera vez.

1. Ir al job `spring-boot-docker-hub`.
2. Hacer clic en `Construir Ahora` (Build Now).

![09.png](assets/section-09/09.png)

Tras unos segundos, veremos que el build aparece en rojo ‚ùå indicando un fallo. Para diagnosticarlo, abrimos el
`Console Output` del build fallido:

![10.png](assets/section-09/10.png)

### üß™ An√°lisis del error en la consola

La mayor parte del proceso se ejecuta correctamente; la construcci√≥n de la imagen Docker finaliza sin inconvenientes:

````bash
...
...
#13 [runtime 3/3] COPY --from=build /app/target/*.jar app.jar
#13 CACHED

#14 exporting to image
#14 exporting layers done
#14 writing image sha256:e2731189f769d7e32eaa555a409b5e6d9ebc4f2c99f56b75ed3927f6c6de9815 done
#14 naming to docker.io/magadiflo/spring-boot-jenkins-app:latest done
#14 DONE 0.0s
... 
````

El error se produce durante el `push a Docker Hub`:

````bash
...
...
[spring-boot-docker-hub] $ docker push magadiflo/spring-boot-jenkins-app:latest
The push refers to repository [docker.io/magadiflo/spring-boot-jenkins-app]
72a0045afbf5: Preparing
a339506eec50: Preparing
8bbd26e5bb80: Preparing
bc7091554844: Preparing
c6974a5a45a3: Preparing
409a60df3c0b: Preparing
256f393e029f: Preparing
409a60df3c0b: Waiting
256f393e029f: Waiting
denied: requested access to the resource is denied
Build step 'Docker Build and Publish' marked build as failure
Finished: FAILURE
````

### ‚ùó ¬øQu√© significa este error?

El mensaje:

> denied: requested access to the resource is denied

Indica que `Docker no tiene permisos para subir la imagen` a `Docker Hub` porque `Jenkins` no est√° autenticado en
`Docker Hub` dentro del contenedor donde est√° ejecut√°ndose.

![11.png](assets/section-09/11.png)

### üõ†Ô∏è Soluci√≥n al error: Autenticar Jenkins en Docker Hub (dentro del contenedor)

Este problema es frecuente cuando se trabaja con `Jenkins` dentro de `Docker`: el contenedor de `Jenkins` tiene
`Docker CLI` instalado, pero no est√° logueado en `Docker Hub`.

Para solucionarlo:

1. Ingresar al contenedor de Jenkins.
2. Autenticar Docker Hub desde dentro del contenedor.
    - Al ejecutar el comando `docker login -u magadiflo`, el CLI nos pedir√° la contrase√±a o mejor a√∫n, un Personal
      Access Token (PAT).
    - Ingresamos nuestra contrase√±a o token.
3. Si la autenticaci√≥n fue exitosa veremos el mensaje `Login Succeeded`.
4. Para validar que estamos autenticados podemos ejecutar este comando `docker info | grep Usernam` que nos mostrar√° el
   usuario logueado.

````bash
$ docker container exec -it c-jenkins /bin/sh
$ docker login -u magadiflo

i Info ‚Üí A Personal Access Token (PAT) can be used instead.
         To create a PAT, visit https://app.docker.com/settings


Password:

WARNING! Your credentials are stored unencrypted in '/var/jenkins_home/.docker/config.json'.
Configure a credential helper to remove this warning. See
https://docs.docker.com/go/credential-store/

Login Succeeded
$ docker info | grep Username
 Username: magadiflo
WARNING: No blkio throttle.read_bps_device support
WARNING: No blkio throttle.write_bps_device support
WARNING: No blkio throttle.read_iops_device support
WARNING: No blkio throttle.write_iops_device support
$ 
````

### üìÅ ¬øD√≥nde guarda Docker las credenciales?

Guarda las credenciales en `/var/jenkins_home/.docker/config.json`. Este archivo queda disponible para futuros builds,
por lo que **ya no tendr√°s que loguearte otra vez**.

### ‚úÖ Resultado

‚û°Ô∏è Con Jenkins ya autenticado dentro del contenedor, la pr√≥xima ejecuci√≥n del job subir√° la imagen correctamente a
Docker Hub.

## üöÄ Segunda Construcci√≥n del Job (Ejecuci√≥n Exitosa)

Despu√©s de autenticarnos correctamente en Docker Hub dentro del contenedor de Jenkins, ya estamos listos para ejecutar
nuevamente nuestro job `spring-boot-docker-hub`.

![12.png](assets/section-09/12.png)

### üéâ Resultado: Build Exitoso

Esta vez el proceso finaliza sin errores, indicando que Jenkins pudo:

- Construir la imagen Docker
- Etiquetarla
- Autenticarse en Docker Hub
- Subirla correctamente

![13.png](assets/section-09/13.png)

### üîç Verificaci√≥n: Console Output

Si revisamos el `Console Output` de esta segunda ejecuci√≥n, veremos que todo ha funcionado correctamente. Ahora s√≠
aparece el bloque final donde se realiza exitosamente el push hacia Docker Hub:

![14.png](assets/section-09/14.png)

## ‚úÖ Verificar en Docker Hub

1. Ve a https://hub.docker.com
2. Inicia sesi√≥n
3. Ve a tus repositorios
4. Deber√≠as ver: `magadiflo/spring-boot-jenkins-app` con los tags `latest` y `2` (o el n√∫mero de build)

![15.png](assets/section-09/15.png)

