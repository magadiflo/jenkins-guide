# ğŸš€ SecciÃ³n 9: Empaquetar una AplicaciÃ³n Spring Boot con Docker

En esta secciÃ³n realizaremos lo que en empresas se conoce como:
**â€œConstrucciÃ³n y empaquetado de una aplicaciÃ³n Java + Spring Boot en una imagen Docker lista para despliegueâ€**.

Aunque en el curso el tutor utiliza una app Node.js, aquÃ­ trabajaremos directamente con nuestro stack
`Java/Spring Boot`, lo cual es mÃ¡s relevante para nuestra lÃ­nea profesional en `CI/CD`.

---

## ğŸ—‚ï¸ Crear repositorio en GitHub con aplicaciÃ³n Spring Boot

Para esta secciÃ³n construiremos una aplicaciÃ³n sencilla de Spring Boot que cumpla con:

- ğŸ§© Un endpoint REST bÃ¡sico.
- ğŸ³ Un `Dockerfile` funcional siguiendo prÃ¡cticas de empresas.
- â˜ï¸ CÃ³digo almacenado en GitHub: https://github.com/magadiflo/spring-boot-jenkins-app

ğŸ“¸ Estructura del repositorio:

![01.png](assets/section-09/01.png)

A continuaciÃ³n mostramos la construcciÃ³n del proyecto base.

### ğŸ“¦ Dependencias del proyecto (Spring Initializr)

El proyecto se creÃ³ usando
[Spring initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.7&packaging=jar&configurationFileFormat=yaml&jvmVersion=21&groupId=dev.magadiflo&artifactId=spring-boot-jenkins-app&name=spring-boot-jenkins-app&description=Demo%20project%20for%20Spring%20Boot&packageName=dev.magadiflo.app&dependencies=web,lombok,actuator)
con las siguientes dependencias:

````xml
<!--Spring Boot 3.5.7-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

### ğŸ› ï¸ ConfiguraciÃ³n del application.yml

````yml
server:
  port: 8081
  error:
    include-message: always

spring:
  application:
    name: spring-boot-jenkins-app
````

ğŸ’¡ Nota:
> En el mundo real, los puertos rara vez se fijan en el cÃ³digo; se parametrizan mediante variables de entorno.
> Pero para este ejemplo estÃ¡ bien dejarlo `hardcodeado` en `8081`.

### ğŸŒ Endpoint REST bÃ¡sico

````java

@RestController
@RequestMapping(path = "/api/v1/greetings")
public class HelloController {
    @GetMapping
    public ResponseEntity<Map<String, Object>> hello() {
        var response = new HashMap<String, Object>();
        response.put("message", "Hola desde Spring Boot + Jenkins!");
        response.put("timestamp", LocalDateTime.now());
        response.put("version", "1.0.0");
        return ResponseEntity.ok(response);
    }
}
````

### ğŸ” VerificaciÃ³n del funcionamiento

âœ”ï¸ Endpoint propio

````bash
$ curl -v http://localhost:8081/api/v1/greetings | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 19 Nov 2025 16:21:45 GMT
<
{
  "message": "Hola desde Spring Boot + Jenkins!",
  "version": "1.0.0",
  "timestamp": "2025-11-19T11:21:45.1053065"
}
````

âœ”ï¸ Endpoint Actuator

````bash
$ curl -v http://localhost:8081/actuator/health | jq
>
< HTTP/1.1 200
< Content-Type: application/vnd.spring-boot.actuator.v3+json
< Transfer-Encoding: chunked
< Date: Wed, 19 Nov 2025 16:22:18 GMT
<
{
  "status": "UP"
}
````

### ğŸ³ Creando el Dockerfile â€” Multi-Stage Build (PrÃ¡ctica de Empresa)

Ubicado en raÃ­z del proyecto (junto al `pom.xml`):

````Dockerfile
# Stage 1: Build con Maven 3.9.11 + Java 21
FROM maven:3.9.11-eclipse-temurin-21 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

# Stage 2: Runtime con JRE 21
FROM eclipse-temurin:21-jre-alpine AS runtime
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8081

# Usar ENTRYPOINT para inmutabilidad
ENTRYPOINT ["java", "-jar", "app.jar"] 
````

ğŸ“Œ Â¿Por quÃ© este Dockerfile? (ExplicaciÃ³n Realista)

| CaracterÃ­stica                                | Beneficio                                              |
|-----------------------------------------------|--------------------------------------------------------|
| ğŸ—ï¸ **Multi-stage build**                     | Reduce tamaÃ±o y mejora seguridad.                      |
| âš™ï¸ **Maven + JDK solo para la fase de build** | No expones herramientas innecesarias en producciÃ³n.    |
| ğŸ”¥ **Imagen final minimalista (JRE Alpine)**  | menos superficie de ataque + menos tiempo de arranque. |
| ğŸ“ **COPY selectivo**                         | Copia solo el JAR final â†’ imagen limpia.               |
| ğŸ› **ENTRYPOINT**                             | Define comando inmutable para ejecuciÃ³n estÃ¡ndar.      |
| ğŸ“¤ **Expose 8081**                            | Documenta el puerto usado por la app (Spring Boot).    |

### ğŸ“¦ Lista final de entregables de esta secciÃ³n

- âœ”ï¸ Proyecto Spring Boot funcional
- âœ”ï¸ Repositorio GitHub correctamente organizado
- âœ”ï¸ Endpoint REST y verificaciÃ³n
- âœ”ï¸ Dockerfile profesional estilo empresa
- âœ”ï¸ Imagen lista para ser construida por Jenkins en la siguiente secciÃ³n

## ğŸš€ InstalaciÃ³n del Plugin: CloudBees Docker Build and Publish

Para habilitar que `Jenkins` pueda construir y publicar imÃ¡genes Docker directamente desde un job, instalaremos
el plugin `CloudBees Docker Build and Publish`.

### ğŸ› ï¸ Â¿QuÃ© es el Plugin `CloudBees Docker Build and Publish`?

El `CloudBees Docker Build and Publish` Plugin para Jenkins es una extensiÃ³n que proporciona pasos de pipeline
(o `build steps` para `jobs de estilo libre`) para interactuar directamente con la tecnologÃ­a `Docker`.

Su propÃ³sito fundamental es permitir que un `job` de `Jenkins`:

1. `Construya (Build)` una imagen de `Docker` a partir de un `Dockerfile`.
2. `Etiquete (Tag)` esa imagen con la convenciÃ³n de nombres y versiones deseada.
3. `Publique (Push)` la imagen resultante a un registro de Docker, como `Docker Hub` (en nuestro caso), un registro
   privado o cualquier otro compatible con la API de Docker.

### ğŸ“¥ Pasos para instalar el plugin

1. âš™ï¸ Ve a `Manage Jenkins` â†’ `Plugins`
2. ğŸ“¦ Ingresa a la pestaÃ±a `Available plugins`
3. ğŸ” Busca: `CloudBees Docker Build and Publish`
4. â˜‘ï¸ SelecciÃ³nalo e instÃ¡lalo

![02.png](assets/section-09/02.png)

5. ğŸ”„ Finalmente, marcamos en `Reiniciar Jenkins...`.

![03.png](assets/section-09/03.png)

