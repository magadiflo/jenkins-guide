# ğŸ“˜ SecciÃ³n 4: Empecemos con Jenkins

---

## ğŸ—ï¸ Arquitectura de Jenkins

`Jenkins` se basa en una arquitectura distribuida que permite ejecutar tareas de automatizaciÃ³n en distintos nodos. A
continuaciÃ³n, se describen sus componentes principales.

### âš™ï¸ Jenkins Job

Un `Job en Jenkins` es una unidad de trabajo automatizada que puede realizar tareas como:

- Compilar cÃ³digo
- Ejecutar pruebas
- Generar artefactos
- Desplegar aplicaciones

Los `Jobs` son definidos por el usuario y supervisados por `Jenkins`. Por ejemplo, podrÃ­amos tener un `job` que realice
las siguientes tareas de forma automÃ¡tica:

1. Descargar el cÃ³digo fuente desde GitHub.
2. Ejecutar `mvn clean package` para compilar y generar el `.jar`.
3. Construir una imagen Docker con tu aplicaciÃ³n.
4. Ejecutar pruebas automatizadas o desplegar la app en un entorno de pruebas.

ğŸ“Œ `Objetivo principal`: automatizar tareas repetitivas del ciclo de vida del desarrollo.

### ğŸ§­ Cambios de terminologÃ­a en Jenkins

| **TÃ©rmino antiguo** | **Nuevo tÃ©rmino (actual)** | **DescripciÃ³n actualizada**                                                                                                                              |
|---------------------|----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Master`            | **Controller**             | Es la instancia principal de Jenkins que orquesta y coordina la ejecuciÃ³n de *jobs*. Se encarga de programar, asignar tareas y gestionar los resultados. |
| `Slave`             | **Agent**                  | Es una mÃ¡quina (fÃ­sica, virtual o contenedor) que realiza los *builds* o tareas que el *controller* le asigna.                                           |
| `Build Node`        | **Node**                   | Hace referencia genÃ©rica tanto al *controller* como a los *agents*.                                                                                      |
| `Build Executor`    | **Executor**               | Permite ejecutar uno o varios *jobs* en paralelo dentro de un nodo.                                                                                      |

### ğŸ§  Jenkins Controller (antes â€œMasterâ€)

El `Controller` (anteriormente llamado `â€œMasterâ€`) es el nÃºcleo de `Jenkins`. Sus responsabilidades incluyen:

- Programar y coordinar los Jobs
- Asignar tareas a los agentes disponibles
- Supervisar la ejecuciÃ³n y registrar los resultados
- Ejecutar Jobs si no hay agentes disponibles

`Nota moderna`: Aunque histÃ³ricamente se usaban los tÃ©rminos `â€œmasterâ€` y `â€œslaveâ€`, `Jenkins` ha adoptado los
tÃ©rminos `controller` y `agent` para promover una terminologÃ­a mÃ¡s inclusiva y clara.

### ğŸ–¥ï¸ Jenkins Agent (antes â€œSlaveâ€)

Un `Agent` es una mÃ¡quina (fÃ­sica o virtual) que `ejecuta los Jobs` asignados por el Controller. Puede ser:

- Un contenedor Docker
- Una VM Linux
- Un servidor remoto

ğŸ“¦ Ejemplo tÃ­pico:

> Un Agent con entorno Java configurado que se encarga exclusivamente de compilar proyectos Spring Boot o ejecutar
> pruebas de integraciÃ³n.

### ğŸ”„ Jenkins Executor

Un `Executor` es una `unidad de ejecuciÃ³n dentro de un Agent`. Permite ejecutar mÃºltiples `Jobs` en paralelo en el
mismo nodo.

- Cada `Agent` puede tener uno o mÃ¡s `Executors`.
- Si un Agent tiene 2 Executors, puede ejecutar 2 Jobs simultÃ¡neamente.

En nuestro entorno local (`Docker Desktop`), el contenedor `Jenkins` normalmente tiene 1 executor por defecto.

### ğŸ§© Plugins de Jenkins

Los `plugins` son extensiones que amplÃ­an la funcionalidad de `Jenkins`. Existen mÃ¡s de 1800 plugins disponibles para:

- IntegraciÃ³n con Git, Maven, Docker, Slack, SonarQube, etc.
- VisualizaciÃ³n de resultados
- GestiÃ³n de credenciales
- Seguridad y autenticaciÃ³n

Los plugins son clave para adaptar Jenkins a cualquier flujo DevOps moderno.

### ğŸ§­ Resumen visual

````bash
+------------------------------------+
|      Jenkins Controller (Master)   |
|        (Orquesta y coordina)       |
+---------------+--------------------+
                |
                v
+---------------+--------------------+
|      Jenkins Agent (Slave)         |
|      (Ejecuta los builds)          |
+---------------+--------------------+
                |
                v
+---------------+--------------------+
|       Jenkins Executors            |
|       (Jobs en paralelo)           |
+---------------+--------------------+
````

Aunque en la documentaciÃ³n o interfaces antiguas aÃºn veas `â€œmasterâ€` o `â€œslaveâ€`, en la documentaciÃ³n oficial de
`Jenkins` y en las versiones recientes (2.3xx en adelante), el lenguaje correcto es:

````bash
controller + Agent architecture
````

## ğŸš€ Primer Job en Jenkins

En esta lecciÃ³n crearemos nuestro `primer Job (tarea)` en `Jenkins`, para comprender el flujo bÃ¡sico de creaciÃ³n,
ejecuciÃ³n y revisiÃ³n de resultados.

### ğŸ§© CreaciÃ³n del Job

En el panel principal de `Jenkins`, seleccionamos `â€œNueva tareaâ€` o `â€œNew Itemâ€`.

![01.png](assets/section-04/01.png)

Escribimos un nombre para nuestro Job (`Primer Job del Curso`) y seleccionamos el tipo
`Crear un proyecto de estilo libre`.

ğŸ’¡ Â¿QuÃ© es un proyecto de estilo libre?
> Es el tipo de proyecto mÃ¡s bÃ¡sico en `Jenkins`. Permite ejecutar comandos o scripts (`shell`, `batch`, etc.) y
> configurar manualmente todo el flujo sin necesidad de usar un `Jenkinsfile` o un `pipeline declarativo`.
> Es ideal para comenzar a familiarizarse con la herramienta.

![02.png](assets/section-04/02.png)

Al hacer clic en `OK`, accedemos a la configuraciÃ³n del `Job`. En el campo de `DescripciÃ³n`, agregamos un texto
explicativo como: `Primer Job del curso de Jenkins`.

![03.png](assets/section-04/03.png)

A continuaciÃ³n nos vamos al final de la pÃ¡gina y en la secciÃ³n `Build Steps` seleccionamos `Ejecutar lÃ­nea de comandos
(shell)`.

![04.png](assets/section-04/04.png)

Se abrirÃ¡ un campo donde podemos ingresar comandos como si estuviÃ©ramos en una terminal. En este ejemplo, escribimos un
comando para imprimir un mensaje.

![05.png](assets/section-04/05.png)

Al hacer clic en `Guardar`, `Jenkins` nos lleva a la pÃ¡gina principal del `Job` reciÃ©n creado.

![06.png](assets/section-04/06.png)

Para lanzar el `Job`, hacemos clic en `â€œConstruir ahoraâ€.` Veremos una ejecuciÃ³n registrada en la parte inferior con
su fecha y estado.

![07.png](assets/section-04/07.png)

Hacemos clic en el Ã­cono de ejecuciÃ³n y seleccionamos `â€œConsole Outputâ€` para ver el resultado del comando.

![08.png](assets/section-04/08.png)

La salida muestra el mensaje que escribimos en el paso anterior.

![09.png](assets/section-04/09.png)

ğŸ§  Nota tÃ©cnica
> `Jenkins` genera un script temporal con los comandos definidos y lo ejecuta internamente.
> Ejemplo: `/tmp/jenkins13962244877367196875.sh`

Finalmente, si vamos al panel de control veremos los detalles de la ejecuciÃ³n de nuestro job con los siguientes
detalles:

- Tiempo desde la Ãºltima ejecuciÃ³n exitosa.
- NÃºmero total de ejecuciones.
- Ãšltimo fallo (si lo hubo).
- DuraciÃ³n de la Ãºltima ejecuciÃ³n.

![10.png](assets/section-04/10.png)

### ğŸ’¡ ConclusiÃ³n

> Con este primer ejercicio, comprobamos que `Jenkins` puede ejecutar comandos directamente dentro de su entorno. En
> adelante, reemplazaremos estos comandos por scripts mÃ¡s avanzados que construyan, prueben y desplieguen aplicaciones
> reales.

## âœï¸ Modificando el comando del Job

En esta lecciÃ³n aprenderemos cÃ³mo editar un Job existente para actualizar los comandos que ejecuta.

### ğŸ”§ Editando la configuraciÃ³n

Desde el panel principal de `Jenkins`, ingresamos al Job `â€œPrimer Job del cursoâ€` y hacemos clic en la opciÃ³n
`â€œConfigurarâ€ (Configure)`.

![11.png](assets/section-04/11.png)

Nos desplazamos hasta la secciÃ³n `â€œBuild Stepsâ€` (Pasos de construcciÃ³n) y modificamos el comando anterior por el
siguiente:

````bash
date +"%T"
````

Este comando imprimirÃ¡ la hora actual en formato de `24 horas (HH:MM:SS)`.

Hacemos clic en `â€œGuardar (Save)â€` para aplicar los cambios.

![12.png](assets/section-04/12.png)

### â–¶ï¸ Ejecutando nuevamente el Job

- Desde la pÃ¡gina principal del Job, seleccionamos `â€œConstruir ahora (Build Now)â€` para lanzar una nueva ejecuciÃ³n.
- Veremos una nueva entrada en el historial de builds (por ejemplo, `#5 16:15` si ya hemos ejecutado varias veces).
- Ingresamos a esa ejecuciÃ³n y abrimos la opciÃ³n `â€œConsole Outputâ€` para revisar la salida.

AllÃ­ veremos el resultado exitoso mostrando la hora actual:

![13.png](assets/section-04/13.png)

ğŸ’¡ Nota

> Con este ejercicio comprobamos que `Jenkins` no solo permite ejecutar comandos simples, sino tambiÃ©n editar
> y versionar fÃ¡cilmente los pasos de ejecuciÃ³n de un Job.  
> Esta flexibilidad serÃ¡ clave cuando mÃ¡s adelante definamos pipelines automatizados con mÃºltiples etapas.

## ğŸ§© Agregando variables a nuestro Job

En esta lecciÃ³n haremos uso de variables dentro de un `Job de Jenkins`, para almacenar informaciÃ³n temporal y
reutilizarla dentro de los comandos ejecutados en el `build step`.

### ğŸ§± Modificando el comando del Job

Ingresamos nuevamente al Job `â€œPrimer Job del Cursoâ€` y seleccionamos la opciÃ³n `â€œConfigurarâ€`.
En la secciÃ³n `Build Steps`, reemplazamos el comando anterior por el siguiente script:

````bash
CURRENT_TIME=$(date +"%r")
echo "La hora actual es: ${CURRENT_TIME}" > /tmp/current_time_file 
````

![14.png](assets/section-04/14.png)

âš™ï¸ ExplicaciÃ³n tÃ©cnica

- `CURRENT_TIME=$(date +"%r")`. Captura la hora actual del sistema en formato de `12 horas (AM/PM)`.
- `echo "La hora actual es: ${CURRENT_TIME}" > /tmp/current_time_file`. Imprime el mensaje con la hora y redirige la
  salida al archivo `/tmp/current_time_file` dentro del contenedor de `Jenkins`.

> ğŸ’¡ `Nota`: El uso de variables en los comandos shell dentro de `Jenkins` permite construir scripts mÃ¡s dinÃ¡micos y
> reutilizables, una prÃ¡ctica comÃºn cuando se parametrizan builds mÃ¡s complejos.

### Ejecutando el Job

Guardamos los cambios y hacemos clic en `â€œConstruir ahoraâ€`. Luego, ingresamos al registro de la ejecuciÃ³n y
seleccionamos `â€œConsole Outputâ€`.

![15.png](assets/section-04/15.png)

Como vemos, la salida en consola serÃ¡ similar a la siguiente:

````bash
Started by user System Admin
Running as SYSTEM
Building in workspace /var/jenkins_home/workspace/Primer Job del Curso
[Primer Job del Curso] $ /bin/sh -xe /tmp/jenkins13373466126245124315.sh
+ date +%r
+ CURRENT_TIME=04:44:36 PM
+ echo La hora actual es: 04:44:36 PM
Finished: SUCCESS 
````

### ğŸ“‚ Verificando el archivo generado

Como el comando redirige la salida al archivo `/tmp/current_time_file`, debemos ingresar al contenedor de `Jenkins`
para comprobar que fue creado correctamente:

````bash
$ docker container exec -it c-jenkins /bin/sh
$ ls -l
total 48
lrwxrwxrwx   1 root root    7 Aug 24 16:20 bin -> usr/bin
drwxr-xr-x   2 root root 4096 Aug 24 16:20 boot
drwxr-xr-x   5 root root  340 Nov 10 14:49 dev
drwxr-xr-x   1 root root 4096 Nov  7 22:10 etc
drwxr-xr-x   2 root root 4096 Aug 24 16:20 home
lrwxrwxrwx   1 root root    7 Aug 24 16:20 lib -> usr/lib
lrwxrwxrwx   1 root root    9 Aug 24 16:20 lib64 -> usr/lib64
drwxr-xr-x   2 root root 4096 Oct 20 00:00 media
drwxr-xr-x   2 root root 4096 Oct 20 00:00 mnt
drwxr-xr-x   1 root root 4096 Nov  4 14:30 opt
dr-xr-xr-x 242 root root    0 Nov 10 14:49 proc
drwx------   1 root root 4096 Nov  4 14:29 root
drwxr-xr-x   1 root root 4096 Nov  4 14:29 run
lrwxrwxrwx   1 root root    8 Aug 24 16:20 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Oct 20 00:00 srv
dr-xr-xr-x  11 root root    0 Nov 10 14:49 sys
drwxrwxrwt   1 root root 4096 Nov 10 16:44 tmp
drwxr-xr-x   1 root root 4096 Oct 20 00:00 usr
drwxr-xr-x   1 root root 4096 Nov  4 14:29 var
$ cd tmp
$ ls -l
total 14264
-rw-r--r-- 1 jenkins jenkins      31 Nov 10 16:44 current_time_file
drwxr-xr-x 2 jenkins jenkins    4096 Nov 10 14:49 hsperfdata_jenkins
drwxr-xr-x 2 jenkins jenkins    4096 Nov 10 14:46 jetty-0_0_0_0-8080-war-_-any-15640770411439023241
drwxr-xr-x 2 jenkins jenkins    4096 Nov  7 22:10 jetty-0_0_0_0-8080-war-_-any-3268185369218364970
drwxr-xr-x 2 jenkins jenkins    4096 Nov 10 14:49 jetty-0_0_0_0-8080-war-_-any-7966640425464047279
-rw-r--r-- 1 jenkins jenkins 4859617 Nov  7 22:10 winstone2345313983222269754.jar
-rw-r--r-- 1 jenkins jenkins 4859617 Nov 10 14:46 winstone4424607586868482556.jar
-rw-r--r-- 1 jenkins jenkins 4859617 Nov 10 14:49 winstone6653401717919977852.jar
$ cat current_time_file
La hora actual es: 04:44:36 PM
````

ğŸ’¡ Nota final

> `Jenkins` ejecuta los `Build Steps` en su propio entorno dentro del contenedor, por lo tanto, cualquier archivo
> generado (como `/tmp/current_time_file`) existe Ãºnicamente dentro del contenedor de `Jenkins`, a menos que se
> configure un volumen compartido para persistirlo o exportarlo.

## ğŸš€ Job v2.0 â€” Creando un Script mÃ¡s Complejo

En esta lecciÃ³n llevaremos nuestro primer `Job` de `Jenkins` a un siguiente nivel. Modificaremos el comando anterior
para ejecutar un `script de shell` mÃ¡s completo, que incluye variables, bucles, condicionales y pausas controladas
`(sleep`).

### ğŸ§© Script de ejemplo

````bash
#!/bin/bash 

# DefiniciÃ³n de variables
NAME="usuario"
COURSE="Jenkins"

# Empieza el loop
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
do
	# Si i = 8, el loop se detiene momentÃ¡neamente
    if [ ${i} -eq 8 ]; then
    	# Dormir 15 segundos
        sleep 15
        echo "A descansar de clase ${COURSE}"
    fi
    echo "Clase NÂ° ${i}"
done

# Dormir 30 segundos
sleep 30
echo "Bien ${NAME}, terminamos las clases de ${COURSE}, Â¡nos vemos!"
````

ğŸ“¸ Agregamos este script dentro del paso `Build Steps` â†’ `Ejecutar lÃ­nea de comandos (shell)`

![16.png](assets/section-04/16.png)

### âš™ï¸ Desglose tÃ©cnico del script

| Elemento                         | DescripciÃ³n                                                                                                                                                                                 |
|----------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `#!/bin/bash`                    | ğŸ”¹ Conocido como `shebang`, indica al sistema operativo que el script debe ser ejecutado con el intÃ©rprete **Bash**. Esto garantiza compatibilidad y control sobre la ejecuciÃ³n del script. |
| `for i in {1..15}`               | ğŸ” Inicia un bucle que recorre los nÃºmeros del 1 al 15.                                                                                                                                     |
| `if [ ${i} -eq 8 ]; then ... fi` | âš¡ Estructura condicional que detiene momentÃ¡neamente la ejecuciÃ³n cuando `i` es igual a `8`.                                                                                                |
| `sleep 15` y `sleep 30`          | â±ï¸ Detienen el flujo por un nÃºmero determinado de segundos. Muy Ãºtil en pipelines donde se deben esperar respuestas de servicios externos.                                                  |
| `echo`                           | ğŸ–¨ï¸ Imprime mensajes en la salida estÃ¡ndar (consola). Jenkins capturarÃ¡ estos mensajes y los mostrarÃ¡ en el `Console Output`.                                                               |

### â–¶ï¸ EjecuciÃ³n del Job

Una vez guardado el script, haz clic en `â€œConstruir ahoraâ€`. Durante la ejecuciÃ³n verÃ¡s una barra de progreso
dinÃ¡mica, ya que el script contiene pausas (`sleep`) programadas.

![17.png](assets/section-04/17.png)

Al finalizar, consulta el `Console Output`. PodrÃ¡s ver cÃ³mo `Jenkins` ejecuta paso a paso el script con las variables
correctamente interpoladas:

![18.png](assets/section-04/18.png)

### ğŸ’¡ Diferencia entre `#!/bin/sh` y `#!/bin/bash`

| IntÃ©rprete    | DescripciÃ³n                                                                                                | Uso recomendado                                            |
|---------------|------------------------------------------------------------------------------------------------------------|------------------------------------------------------------|
| `#!/bin/sh`   | Shell mÃ¡s bÃ¡sico y compatible con la mayorÃ­a de los sistemas Unix. Ideal para scripts simples y portables. | âœ… Scripts ligeros y universales.                           |
| `#!/bin/bash` | VersiÃ³n extendida con soporte para arrays, condicionales avanzadas, globbing, autocompletado y funciones.  | ğŸ’ª Scripts complejos como los usados en Jenkins Pipelines. |

ğŸ§  ConclusiÃ³n
> En este caso usamos `#!/bin/bash` porque nos da acceso a estructuras de control mÃ¡s potentes y es el estÃ¡ndar de
> facto en entornos de automatizaciÃ³n modernos.

### ğŸ§± En un entorno real (para desarrolladores Java/Spring Boot)

En equipos backend, scripts como este pueden servir para:

- Ejecutar tests automatizados antes de un build Maven.
- Limpiar directorios temporales o generar logs.
- Desplegar artefactos `.jar` en entornos de prueba.
- Controlar dependencias o pausar procesos hasta que un contenedor estÃ© listo (por ejemplo, esperar a que una base de
  datos se levante antes de ejecutar pruebas de integraciÃ³n).

### ğŸ’¼ Buena prÃ¡ctica

En pipelines reales, estos comandos no se escriben manualmente en cada `Job`. En su lugar, se centralizan en scripts
almacenados y versionados dentro del repositorio (por ejemplo, `scripts/build.sh`).

`Jenkins` clona el repositorio y ejecuta estos scripts como parte del proceso de construcciÃ³n, garantizando asÃ­ que la
lÃ³gica de build estÃ© sincronizada con el cÃ³digo del proyecto.

## ğŸš€ Job v2.0 â€” Script desde el contenedor

En la lecciÃ³n anterior modificamos nuestro job para ejecutar un `script de shell` mÃ¡s complejo directamente desde
`Jenkins`.

En esta ocasiÃ³n, haremos lo mismo, pero `ejecutando el script dentro del contenedor de Jenkins`, lo que nos permitirÃ¡
ver cÃ³mo `Jenkins` puede invocar scripts que existen en su propio entorno. AdemÃ¡s, reduciremos los tiempos de espera
(`sleep`) para no alargar demasiado la ejecuciÃ³n.

### ğŸ§© 1. Crear el script en el proyecto local

Creamos un archivo llamado `jobscript.sh` dentro del directorio `/scripts` del proyecto  `jenkins-guide`. El contenido
del archivo serÃ¡ el siguiente:

````bash
#!/bin/bash

# DefiniciÃ³n de variables
NAME="usuario"
COURSE="Jenkins"

# Empieza el loop
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
do
	# Si i = 8, el loop se detiene momentÃ¡neamente
    if [ ${i} -eq 8 ]; then
    	# Dormir 5 segundos
        sleep 5
        echo "A descansar de clase ${COURSE}"
    fi
    echo "Clase NÂ° ${i}"
done

# Dormir 5 segundos
sleep 5
echo "Bien ${NAME}, terminamos las clases de ${COURSE}, Â¡nos vemos!" 
````

### ğŸ§ª 2. Probar el script en la mÃ¡quina local

Antes de llevar el script `jobscript.sh` al contenedor, validamos que funcione correctamente desde nuestro entorno
local (por ejemplo, usando `Cmder`):

````bash
D:\programming\jenkins\jenkins-guide (section-04)
$ sh .\scripts\jobscript.sh
Clase NÂ° 1
Clase NÂ° 2
Clase NÂ° 3
Clase NÂ° 4
Clase NÂ° 5
Clase NÂ° 6
Clase NÂ° 7
A descansar de clase Jenkins
Clase NÂ° 8
Clase NÂ° 9
Clase NÂ° 10
Clase NÂ° 11
Clase NÂ° 12
Clase NÂ° 13
Clase NÂ° 14
Clase NÂ° 15
Bien usuario, terminamos las clases de Jenkins, Â¡nos vemos!
````

### ğŸ“¦ 3. Copiar el script dentro del contenedor de Jenkins

Para ejecutar el script directamente dentro del contenedor `c-jenkins`, debemos copiarlo usando el comando
`docker container cp`:

````bash
D:\programming\jenkins\jenkins-guide (section-04)
$ docker container cp .\scripts\jobscript.sh c-jenkins:/opt
Successfully copied 2.05kB to c-jenkins:/opt
````

ğŸ’¡ ExplicaciÃ³n tÃ©cnica:
> El comando `docker container cp` nos permite transferir archivos desde el sistema anfitriÃ³n hacia el contenedor
> (o viceversa).
>
> En este caso, copiamos el archivo `jobscript.sh` al directorio `/opt` dentro del contenedor `c-jenkins`
> (por convenciÃ³n, `/opt` se usa para archivos opcionales o personalizados del sistema).

### ğŸ§­ 4. Verificar el script dentro del contenedor

Ingresamos al contenedor para comprobar que el archivo fue copiado correctamente y tiene permisos de ejecuciÃ³n:

````bash
$ docker container exec -it c-jenkins /bin/sh
$ ls -l
total 52
lrwxrwxrwx   1 root root    7 Aug 24 16:20 bin -> usr/bin
drwxr-xr-x   2 root root 4096 Aug 24 16:20 boot
drwxr-xr-x   5 root root  340 Nov 11 03:42 dev
drwxr-xr-x   1 root root 4096 Nov  7 22:10 etc
drwxr-xr-x   2 root root 4096 Aug 24 16:20 home
lrwxrwxrwx   1 root root    7 Aug 24 16:20 lib -> usr/lib
lrwxrwxrwx   1 root root    9 Aug 24 16:20 lib64 -> usr/lib64
drwxr-xr-x   2 root root 4096 Oct 20 00:00 media
drwxr-xr-x   2 root root 4096 Oct 20 00:00 mnt
-rwxr-xr-x   1 root root  440 Nov 11 03:59 op
drwxr-xr-x   1 root root 4096 Nov 11 04:10 opt
dr-xr-xr-x 240 root root    0 Nov 11 03:42 proc
drwx------   1 root root 4096 Nov  4 14:29 root
drwxr-xr-x   1 root root 4096 Nov  4 14:29 run
lrwxrwxrwx   1 root root    8 Aug 24 16:20 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Oct 20 00:00 srv
dr-xr-xr-x  11 root root    0 Nov 11 04:05 sys
drwxrwxrwt   1 root root 4096 Nov 11 03:42 tmp
drwxr-xr-x   1 root root 4096 Oct 20 00:00 usr
drwxr-xr-x   1 root root 4096 Nov  4 14:29 var
$ cd opt
$ ls -l
total 6792
drwxr-xr-x 3 root root    4096 Nov  4 14:30 java
-rw-r--r-- 1 root root 6945015 Nov  4 14:29 jenkins-plugin-manager.jar
-rwxr-xr-x 1 root root     440 Nov 11 03:59 jobscript.sh
$ cat jobscript.sh
#!/bin/bash

# DefiniciÃ³n de variables
NAME="usuario"
COURSE="Jenkins"

# Empieza el loop
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
do
        # Si i = 8, el loop se detiene momentÃ¡neamente
    if [ ${i} -eq 8 ]; then
        # Dormir 5 segundos
        sleep 5
        echo "A descansar de clase ${COURSE}"
    fi
    echo "Clase NÂ° ${i}"
done

# Dormir 5 segundos
sleep 5
echo "Bien ${NAME}, terminamos las clases de ${COURSE}, Â¡nos vemos!"
````

### âš™ï¸ 5. Ejecutar el script manualmente dentro del contenedor

Ejecutamos el archivo dentro del contenedor para confirmar que funciona:

````bash
$ ./jobscript.sh
Clase NÂ° 1
Clase NÂ° 2
Clase NÂ° 3
Clase NÂ° 4
Clase NÂ° 5
Clase NÂ° 6
Clase NÂ° 7
A descansar de clase Jenkins
Clase NÂ° 8
Clase NÂ° 9
Clase NÂ° 10
Clase NÂ° 11
Clase NÂ° 12
Clase NÂ° 13
Clase NÂ° 14
Clase NÂ° 15
Bien usuario, terminamos las clases de Jenkins, Â¡nos vemos!
````

### 6. Configurar el Job para usar el script del contenedor

Ahora que el script ya se encuentra dentro del contenedor y validamos su funcionamiento, regresamos a la interfaz web
de `Jenkins` y vamos a `Configurar el job`.

- Eliminamos el contenido anterior del bloque de comandos del `Build Steps`.
- En su lugar, escribimos solo la ruta al script dentro del contenedor:

  ![19.png](assets/section-04/19.png)

- Luego damos clic en Guardar.

### ğŸš€ 7. Ejecutar el Job desde Jenkins

Volvemos al panel principal del job y seleccionamos `Construir ahora`. `Jenkins` ejecutarÃ¡ el script ubicado dentro
del contenedor, y veremos la barra de progreso avanzando normalmente.

![20.png](assets/section-04/20.png)

### ğŸ“„ 8. Revisar la salida en consola

Finalmente, abrimos la Ãºltima ejecuciÃ³n del job y accedemos a la opciÃ³n `Console Output`. AllÃ­ observamos que
`Jenkins` ejecutÃ³ correctamente el archivo `/opt/jobscript.sh` dentro del contenedor, mostrando todas las salidas
esperadas.

![21.png](assets/section-04/21.png)
