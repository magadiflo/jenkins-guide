# ğŸš€ SecciÃ³n 12: Jenkins Job DSL

---

## ğŸ§© IntroducciÃ³n al Job DSL

El tÃ©rmino `DSL (Domain Specific Language)` hace referencia a un lenguaje diseÃ±ado para resolver problemas dentro
de un dominio especÃ­fico. En el caso de `Jenkins`, el `Job DSL` permite
`definir, crear y actualizar jobs usando cÃ³digo`, en lugar de configurarlos manualmente desde la interfaz web.

Esto es especialmente Ãºtil en empresas donde se requiere:

- EstÃ¡ndares de configuraciÃ³n entre cientos de jobs.
- Versionar pipelines y plantillas.
- Automatizar despliegues de la infraestructura de CI/CD.

### ğŸ› ï¸ Â¿QuÃ© es el plugin Jenkins Job DSL?

El plugin `Jenkins Job DSL` permite generar jobs mediante archivos escritos en `Groovy` (*`Groovy` es un lenguaje de
scripting dinÃ¡mico para la plataforma Java*). Con este plugin podemos
escribir cÃ³digo que describa:

- Freestyle jobs
- Pipeline jobs
- Vistas
- Carpetas
- Configuraciones completas de la interfaz

De esta manera, Jenkins se convierte en un sistema declarativo, donde el cÃ³digo es la fuente de verdad para los jobs.

> ğŸ’¡ Para poder usar `Job DSL` es indispensable instalar el plugin oficial: `Job DSL Plugin`

### ğŸ§µ Â¿Por quÃ© usar Job DSL? (Beneficios Reales)

Los usuarios pueden describir sus jobs mediante scripts basados en `Groovy`, lo que habilita ventajas muy alineadas con
las prÃ¡cticas modernas de CI/CD:

#### âœ”ï¸ Rollbacks seguros

Puedes revertir un cambio en un job simplemente regresando a una versiÃ³n anterior del script en Git.

#### âœ”ï¸ Historial de cambios y auditorÃ­a

Cada modificaciÃ³n a un job queda registrada en el control de versiones (Git), no solo en la UI de Jenkins.

#### âœ”ï¸ Control de versiones

Los jobs pasan a ser infraestructura como cÃ³digo (IaC), facilitando:

- Revisiones por PR
- Control de calidad en cambios de pipelines
- Despliegue consistente de jobs en distintos entornos (Dev, QA, Prod)

#### âœ”ï¸ AutomatizaciÃ³n completa

Puedes crear cientos de jobs automÃ¡ticamente a partir de una plantilla.

### ğŸ¢ Â¿CÃ³mo se usa en empresas reales?

En el mundo profesional, `Job DSL` se emplea para:

- Definir plantillas estandarizadas para equipos completos.
- Crear jobs automÃ¡ticamente para nuevos repositorios.
- Evitar configuraciones manuales que producen errores humanos.
- Mantener versiones claras de los pipelines (GitOps + CI/CD).
- Generar mÃºltiples pipelines basados en parÃ¡metros (ej: microservicios).
- Reducir inconsistencias entre entornos o equipos.

ğŸ’¡ En entornos empresariales grandes, `Job DSL` convive con `Jenkins Pipeline` (declarativo o scripted).
Suele usarse asÃ­:

| Uso                         | Herramienta      |
|-----------------------------|------------------|
| Crear la estructura del job | Job DSL          |
| Ejecutar el pipeline real   | Jenkins Pipeline |

## âš™ï¸ InstalaciÃ³n del Plugin Job DSL

Para utilizar `Job DSL` en `Jenkins`, primero debemos instalar el plugin oficial. Este plugin nos permitirÃ¡ definir
jobs mediante cÃ³digo `Groovy` y habilita las herramientas necesarias para generar, actualizar y gestionar
configuraciones desde scripts.

Nos vamos a `Administrar Jenkins` â†’ `Plugins` y buscamos `Job DSL`, lo seleccionamos y procedemos a instalar.

![01.png](assets/section-12/01.png)

Seleccionamos `Reiniciar Jenkins cuando termina la instalaciÃ³n...` y esperamos mientras se instala.

![02.png](assets/section-12/02.png)

## ğŸŒ± Seed Job & Description (Fundamentos del Job DSL)

Para utilizar correctamente el `Plugin Job DSL`, lo primero que debemos crear es un `Seed Job`.

Un `Seed Job` es un job normal de Jenkins (igual que los jobs de estilo libre que hemos estado creando), pero con
la particularidad de que incluye el paso `Process Job DSLs`. Este paso le permite ejecutar
`scripts DSL escritos en Groovy` para crear o actualizar otros jobs automÃ¡ticamente. A partir de estos scripts es
posible:

- Crear nuevos jobs.
- Actualizar configuraciones.
- Regenerar plantillas.
- Aplicar cambios en masa.

En otras palabras:

> ğŸ§  El `Seed Job` es el `â€œjob padreâ€` que genera otros jobs automÃ¡ticamente mediante cÃ³digo.

### ğŸ” Â¿Por quÃ© existe el Seed Job?

Porque `Jenkins`, por defecto, solo ejecuta lo que le asignamos manualmente. El `Seed Job` actÃºa como
â€œintÃ©rpreteâ€ del DSL, permitiendo:

- Automatizar creaciÃ³n de pipelines.
- Mantener jobs versionados.
- Facilitar la estandarizaciÃ³n en equipos grandes.
- Evitar configuraciones manuales desde la UI.
- Regenerar jobs cuando cambian las plantillas.

> ğŸ’¡ En empresas, los `Seed Jobs` suelen correr automÃ¡ticamente al recibir cambios en su repositorio Git.

### ğŸ› ï¸ Crear el Seed Job y configurar el DSL

Creamos un job de estilo libre llamado: `dsl-job`. Este serÃ¡ nuestro `Seed Job` inicial.

![03.png](assets/section-12/03.png)

Dentro del job, nos dirigimos al `Build Steps` y en `+ AÃ±adir un nuevo paso` seleccionamos `Process Job DSLs`.

![04.png](assets/section-12/04.png)

### ğŸ“ Opciones del procesamiento DSL

Al agregar el paso, aparecen dos opciones:

- ğŸ”¸ OpciÃ³n 1: `Use the provided DSL script`.
    - Permite escribir el cÃ³digo directamente en la interfaz del job.
    - Suele usarse solo para pruebas o demos.

- ğŸ”¸ OpciÃ³n 2: `Look on Filesystem`
    - Permite cargar uno o varios archivos `.groovy` desde el workspace del job.
    - Esta es la forma usada en empresas, pues el DSL se versiona en Git.

En este punto usaremos la `opciÃ³n 1` para una demostraciÃ³n.

![05.png](assets/section-12/05.png)

### ğŸ“ Ejemplo bÃ¡sico de DSL Script

Al seleccionar la `opciÃ³n 1`, aparece un cuadro de texto para escribir el script. Usaremos este ejemplo simple:

````bash
job('ejemplo-job-DSL') {
  
}
````

Este script indica:

> ğŸ”¨ Crear un nuevo job llamado `ejemplo-job-DSL` utilizando como base este seed job (`dsl-job`).

Nota:
> En el siguiente enlace https://jenkinsci.github.io/job-dsl-plugin podemos ver informaciÃ³n sobre `Jenkins Job DSL API`


![06.png](assets/section-12/06.png)

### â–¶ï¸ Ejecutando el Job DSL

Guardamos el Seed Job y luego hacemos clic en: `Construir Ahora`. Sin embargo, veremos que aparece un error:

![07.png](assets/section-12/07.png)

### ğŸ›¡ï¸ Â¿Por quÃ© aparece el error?

Porque `Jenkins`, por seguridad, `no ejecuta scripts Groovy no aprobados`. `Jenkins` requiere revisar los scripts
para evitar ejecuciÃ³n de cÃ³digo potencialmente peligroso.

Debemos aprobarlos manualmente:

````
Administrar Jenkins â†’ In-process Script Approval 
````

![08.png](assets/section-12/08.png)

### âœ”ï¸ Aprobando el script

Entramos a `In-Process Script Approval` y hacemos clic en: `Approve`.

![09.png](assets/section-12/09.png)

DespuÃ©s de aprobarlo, volvemos a ejecutar el Seed Job y veremos que ahora el build finaliza correctamente:

![10.png](assets/section-12/10.png)

### ğŸ‰ Verificando que el job fue creado

Vamos al panel principal de Jenkins y veremos que se generÃ³ un nuevo job: `ejemplo-job-DSL`.

![11.png](assets/section-12/11.png)

Y si ingresamos al job reciÃ©n creado, veremos la referencia: `Seed job: dsl-job`. Esto nos confirma que el job fue
creado mediante cÃ³digo usando nuestro Seed Job.

![12.png](assets/section-12/12.png)

## ğŸ“ Source Control Management (SCM)

En esta lecciÃ³n aprenderemos a integrar `GitHub` dentro de un `Job` creado mediante `Jenkins Job DSL`, indicÃ¡ndole
desde quÃ© repositorio debe clonar el cÃ³digo fuente para ejecutar el pipeline o los scripts asociados.

Integrar correctamente `SCM` es fundamental en entornos empresariales, ya que:

- Permite ejecutar pipelines reproducibles.
- Garantiza que el cÃ³digo provenga siempre de una fuente controlada.
- Hace posible trabajar con branching models modernos (`GitFlow`, `trunk-based development`).
- Facilita auditorÃ­as y trazabilidad.

### ğŸ” Conociendo el Git SCM Source en Job DSL

Para definir el origen del cÃ³digo dentro del script DSL, utilizamos el bloque `scm { ... }`.

En la documentaciÃ³n oficial del plugin:

â¡ï¸ [Jenkins Job DSL Plugin](https://jenkinsci.github.io/job-dsl-plugin/#method/javaposse.jobdsl.dsl.helpers.ScmContext.git)
encontraremos ejemplos como este:

![13.png](assets/section-12/13.png)

En la imagen vemos el `example-3`, mismo que se representa a continuaciÃ³n.

````bash
// add user name and email options
job('example-3') {
    scm {
        git('git@git') { node -> // is hudson.plugins.git.GitSCM
            node / gitConfigName('DSL User')
            node / gitConfigEmail('me@me.com')
        }
    }
} 
````

#### ğŸ“ Â¿QuÃ© son `gitConfigName` y `gitConfigEmail`?

- Estos parÃ¡metros dentro del bloque `scm` estÃ¡n configurando la identidad que `Git` utilizarÃ¡ para firmar cualquier
  nuevo commit que Jenkins haga en el repositorio.
- Esto es el equivalente a ejecutar los siguientes comandos de Git dentro del espacio de trabajo del job de Jenkins (si
  el job hiciera un commit):
    ````bash
    git config user.name "DSL User"
    git config user.email "me@me.com" 
    ````
- `Â¿Son importantes?` SÃ­, porque si tu job realiza una acciÃ³n que resulta en un commit (por ejemplo, actualizando un
  nÃºmero de versiÃ³n o un archivo de configuraciÃ³n), esta es la informaciÃ³n del autor que aparecerÃ¡ en el historial de
  Git.

### ğŸ§ª Ejemplo previo usado en el curso

Anteriormente, probamos este script desde un job parametrizable de tipo Freestyle llamado `ParÃ¡metro booleano en Job`:

````bash
#!/bin/bash
echo "Bienvenido al planeta ${PLANET}"
if [ "${AGENT}" = "true" ] 
then
	echo "PrepÃ¡rese para la misiÃ³n agente X, que la fuerza te acompaÃ±e."
else
	echo "Disfruta el planeta humano ${NAME}, trata de no morir"
fi
echo "..."
sleep 10
echo "Â¡Suerte! La necesitarÃ¡s." 
````

Este mismo script estarÃ¡ subido en el repositorio de GitHub del tutor en un archivo llamado `jobscript.sh`, tal como
se muestra a continuaciÃ³n.

![14.png](assets/section-12/14.png)

### ğŸ› ï¸ Realizando el Ejemplo con Job DSL

Nos dirigimos al `Seed Job` `dsl-job` â†’ `Configure` â†’ `Build Steps` â†’ `Process Job DSLs`, e insertamos lo siguiente:

````bash
job('ejemplo-job-DSL') {
  description('Job DSL de ejemplo para el curso de Jenkins')
  scm {
        git('https://github.com/macloujulian/jenkins.job.parametrizado.git', 'main') { node ->
            node / gitConfigName('MartÃ­n DÃ­az')
            node / gitConfigEmail('magadiflo@gmail.com')
        }
    }
}
````

#### ğŸ’¡ Â¿QuÃ© hace este script?

- Crea un nuevo job llamado `ejemplo-job-DSL`.
- Configura `Git SCM` apuntando al repositorio `GitHub`.
- Selecciona la rama `main`.
- Define el nombre y correo del autor si Jenkins ejecuta operaciones Git.

En la siguiente imagen se observa la modificaciÃ³n anterior.

![15.png](assets/section-12/15.png)

Luego de dar en `Save`, vamos a `Construir ahora`. Probablemente, el job no se ejecute y nos muestre un mensaje
de error `ERROR: script not yet approved for use`.

### ğŸ” Mensaje de error: `script not yet approved for use`

El error `ERROR: script not yet approved for use` significa que el Groovy Sandbox de Jenkins estÃ¡ bloqueando la
ejecuciÃ³n del script porque contiene mÃ©todos o clases que Jenkins considera potencialmente inseguros.

Cuando ejecutas un Seed Job que usa Job DSL, en realidad estÃ¡s ejecutando un script Groovy. Jenkins tiene un mecanismo
de seguridad (el `In-process Script Approval`) para evitar que scripts maliciosos puedan daÃ±ar el sistema de archivos o
acceder a informaciÃ³n sensible.

Para resolver esto, debemos aprobar manualmente el script del Job DSL.

![16.png](assets/section-12/16.png)

### âœ”ï¸ EjecuciÃ³n Exitosa

Cuando el Seed Job corre nuevamente:

- El script queda aprobado.
- El job `ejemplo-job-DSL` se crea correctamente.
- La configuraciÃ³n SCM aparece con el repositorio y la rama definida.

![17.png](assets/section-12/17.png)

Dentro de este `Seed Job` llamado `dls-job` vemos un job `ejemplo-job-DSL`, ingresamos en Ã©l y vemos que `Git`
se ha configurado indicando el `repositorio de GitHub` y la rama `main`.

![18.png](assets/section-12/18.png)

Recordemos que el `Process Job DSLs` inicia con `job('ejemplo-job-DSL'){...}`, por eso es que la configuraciÃ³n de git
y el repositorio de GitHub se aplicaron a ese job.

### ğŸ“Œ ConclusiÃ³n

- El bloque `scm` en Job DSL permite integrar repositorios GitHub directamente en la definiciÃ³n de jobs.
- Es fundamental configurar nombre y email para que los commits generados por Jenkins tengan identidad clara.
- En Jenkins, los scripts DSL son Groovy y requieren aprobaciÃ³n de seguridad antes de ejecutarse.
- Una vez aprobado, el job queda listo para usar el cÃ³digo fuente del repositorio remoto.

## ğŸ›ï¸ ParÃ¡metros en Jenkins DSL (Job DSL)

En esta lecciÃ³n aprenderemos cÃ³mo definir parÃ¡metros en un Job utilizando `Jenkins Job DSL`.
Los parÃ¡metros permiten que un job sea dinÃ¡mico, configurable y reutilizable; son ampliamente usados en entornos
reales para:

- Deploys a distintos entornos (`DEV`, `QA`, `PROD`).
- Activar o desactivar funcionalidades.
- Pasar variables a scripts (como nuestro `jobscript.sh`).
- Seleccionar versiones, ramas o artefactos.
- Cambiar comportamientos del pipeline segÃºn valores de entrada.

### ğŸ“š Consultando documentaciÃ³n oficial

En la documentaciÃ³n del plugin:
â¡ï¸ [Jenkins Job DSL Plugin](https://jenkinsci.github.io/job-dsl-plugin/#method/javaposse.jobdsl.dsl.jobs.FreeStyleJob.parameters)

Encontramos el siguiente ejemplo bÃ¡sico:

````bash
job('example') {
    parameters {
        booleanParam('FLAG', true)
        choiceParam('OPTION', ['option 1 (default)', 'option 2', 'option 3'])
    }
}
````

ğŸ’¡ Â¿QuÃ© hace este ejemplo?

- `booleanParam` â†’ crea un checkbox
- `choiceParam` â†’ crea una lista desplegable con opciones

Este patrÃ³n es el que usaremos para definir nuestros parÃ¡metros personalizados.

![19.png](assets/section-12/19.png)

### ğŸ› ï¸ Configurando parÃ¡metros para el ejemplo real del curso

Nuestro script `jobscript.sh` descargado desde GitHub requiere los parÃ¡metros:

- NAME
- PLANET
- AGENT

Por lo tanto, debemos agregar esos parÃ¡metros mediante el `DSL`. Volvemos a nuestro
`Seed Job` â†’ `Configure` â†’ `Process Job DSLs` y agregamos los parÃ¡metros dentro del job `ejemplo-job-DSL`.

````bash
job('ejemplo-job-DSL') {
  description('Job DSL de ejemplo para el curso de Jenkins')
  scm {
        git('https://github.com/macloujulian/jenkins.job.parametrizado.git', 'main') { node ->
            node / gitConfigName('MartÃ­n DÃ­az')
            node / gitConfigEmail('magadiflo@gmail.com')
        }
    }
  parameters {
    stringParam('NAME', 'Milagritos', 'ParÃ¡metro de cadena para el Job Booleano')
    choiceParam('PLANET', ['Mercurio', 'Venus', 'Tierra', 'Marte', 'JÃºpiter', 'Saturno', 'Urano', 'Neptuno', 'PlutÃ³n'], 'Lista de parÃ¡metros')
    booleanParam('AGENT', false)
  }
} 
````

![20.png](assets/section-12/20.png)

Damos en `Save` y vamos a `Construir ahora`. Si nos aparece el error `ERROR: script not yet approved for use`
ya sabemos que debemos aprobar la ejecuciÃ³n de ese job en:
`Administrar Jenkins` > `In-process Script Approval`.

### ğŸ–¼ï¸ ConfiguraciÃ³n visual en la UI

Al ejecutar el `Seed Job` y despuÃ©s ir al `ejemplo-job-DSL`, veremos los parÃ¡metros listos para ser usados.

![21.png](assets/section-12/21.png)

Esto confirma que el DSL del `Seed Job` estÃ¡ creando correctamente los parÃ¡metros en el job destino.

### âš™ï¸ Â¿Por quÃ© los parÃ¡metros aparecen en `ejemplo-job-DSL`?

Porque el Seed Job ejecuta:

````bash
job('ejemplo-job-DSL') { ... } 
````

Todo lo que estÃ© dentro de ese bloque se aplica `al job que estamos declarando` y no al `Seed Job`.
El Seed Job solo sirve para `crear o actualizar` otros jobs. Este patrÃ³n es estÃ¡ndar en grandes empresas:

#### ğŸ§© PatrÃ³n tÃ­pico en entornos reales

- `Seed Job`: crea/actualiza cientos de jobs automÃ¡ticamente.
- `Jobs generados por DSL`: contienen toda la configuraciÃ³n (SCM, parÃ¡metros, triggers, etc.).
- La configuraciÃ³n vive en cÃ³digo, no en clics manuales.

### Verifica parÃ¡metros en job `ejemplo-job-DSL`

Si damos clic en `Build with Parameters` en el job `ejemplo-job-DSL`, vemos que nos aparece los parÃ¡metros configurados.

![22.png](assets/section-12/22.png)

## â±ï¸ Triggers & Wrappers en Jenkins Job DSL

En esta lecciÃ³n aprenderemos a utilizar dos conceptos fundamentales cuando definimos jobs mediante `Jenkins Job DSL`:

- `Wrappers` â†’ Acciones adicionales antes/despuÃ©s del job.
- `Triggers` â†’ Programar la ejecuciÃ³n de un job automÃ¡ticamente.

Ambos son utilizados en entornos empresariales para controlar el comportamiento de los jobs y automatizar procesos de
CI/CD.

### ğŸ Wrappers

Un `wrapper` es un bloque que permite agregar comportamientos adicionales al job, ya sea antes o despuÃ©s de la
ejecuciÃ³n.

Ejemplos tÃ­picos en empresas:

- âœ”ï¸ Configurar timeout.
- âœ”ï¸ Ejecutar el job en un entorno controlado.
- âœ”ï¸ Agregar timestamps a la consola.
- âœ”ï¸ Activar ansiColor.
- âœ”ï¸ Enmascarar logs con credenciales.

Aunque lo estudiaremos mÃ¡s adelante con profundidad, podemos describirlo asÃ­:

> ğŸ’¡ `Wrapper` = comportamiento extra antes o despuÃ©s de la ejecuciÃ³n del job.

Ejemplo real:

````groovy
wrappers {
    timeout {
        absolute(10) // falla el job si dura mÃ¡s de 10 minutos
    }
    timestamps() // agrega tiempo a cada lÃ­nea del log
} 
````

### â±ï¸ Triggers en Jenkins

Los `triggers` permiten ejecutar un job de manera automÃ¡tica sin intervenciÃ³n humana.

En el mundo real esto se usa para:

- Ejecutar builds diarios o nocturnos (nightly builds).
- Validar ramas periÃ³dicamente.
- Sincronizar repositorios.
- Generar reportes automÃ¡ticos.
- Automatizar tareas repetitivas.

En `Job DSL`, un trigger comÃºn es el `cron`.

### ğŸ§© Â¿QuÃ© es un cron?

Un `cron` es una expresiÃ³n que indica cuÃ¡ndo debe ejecutarse algo. Tiene 5 campos:

````scss
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Minutos (0 - 59)
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€ Hora (0 - 23)
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€ DÃ­a del mes (1 - 31)
â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€ Mes (1 - 12)
â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€ DÃ­a de la semana (0 - 7)
â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ â”‚
* * * * * 
````

Ejemplos:

| ExpresiÃ³n   | Significa                                |
|-------------|------------------------------------------|
| `* * * * *` | Cada minuto                              |
| `0 * * * *` | Cada hora exacta                         |
| `0 0 * * *` | Todos los dÃ­as a medianoche              |
| `H * * * *` | Una vez por hora, usando hashing estable |

#### ğŸ’¡ `H` en Jenkins

`Jenkins` incluye la letra `H (hash)` para distribuir automÃ¡ticamente las ejecuciones y evitar que todos los
jobs corran a la vez. Es una mejor prÃ¡ctica recomendada en empresas.

Ejemplo:

````bash
H/7 * * * *
````

â¡ï¸ `Ejecuta el job cada 7 minutos`, pero no siempre en el mismo minuto exacto. Esto balancea la carga del servidor.

### ğŸ§© Nota rÃ¡pida sobre el formato `cron` en otros sistemas

En `Apache Camel` los `cron` usan `6 campos` porque se basan en `Quartz Cron`, que incluye el campo de segundos:

````bash
Segundos  Minutos  Horas  DÃ­aMes  Mes  DÃ­aSemana 
````

En `Jenkins`, en cambio, el `cron` usa el formato `Unix clÃ¡sico` de `5 campos`, sin segundos:

````bash
Minutos  Horas  DÃ­aMes  Mes  DÃ­aSemana
````

ğŸ’¡ Por eso en `Camel` verÃ¡s `expresiones con 6 asteriscos`, mientras que en `Jenkins solo 5`.

### ğŸ› ï¸ Trigger en Job DSL

AsÃ­ se define un trigger con cron:

````groovy
triggers {
    cron('H/7 * * * *')
} 
````

### ğŸ§± DSL Completo con SCM, ParÃ¡metros y Trigger

AquÃ­ estÃ¡ el script completo utilizado en esta lecciÃ³n:

````groovy
job('ejemplo-job-DSL') {
    description('Job DSL de ejemplo para el curso de Jenkins')
    scm {
        git('https://github.com/macloujulian/jenkins.job.parametrizado.git', 'main') { node ->
            node / gitConfigName('MartÃ­n DÃ­az')
            node / gitConfigEmail('magadiflo@gmail.com')
        }
    }
    parameters {
        stringParam('NAME', 'Milagritos', 'ParÃ¡metro de cadena para el Job Booleano')
        choiceParam('PLANET', ['Mercurio', 'Venus', 'Tierra', 'Marte', 'JÃºpiter', 'Saturno', 'Urano', 'Neptuno', 'PlutÃ³n'], 'Lista de parÃ¡metros')
        booleanParam('AGENT', false)
    }
    triggers {
        cron('H/7 * * * *') // Se ejecuta cada 7 minutos
    }
}
````

La imagen muestra lo mismo que el cÃ³digo anterior.

![23.png](assets/section-12/23.png)

### ğŸ–¼ï¸ VisualizaciÃ³n en Jenkins

Luego de ejecutar el `Seed Job` (recordemos aprobar el script en `Manage Jenkins` â†’ `In-process Script Approval`).

![24.png](assets/section-12/24.png)

El job generado `ejemplo-job-DSL` mostrarÃ¡ el trigger configurado:

![25.png](assets/section-12/25.png)

Como podemos observar, en la opciÃ³n `Triggers` se muestra el crÃ³n definido anteriormente. Este trigger se ejecutarÃ¡
cada 7 minutos.

## ğŸš€ Steps (Build Steps en Job DSL)

Los `Steps` permiten definir quÃ© acciones ejecutarÃ¡ un job durante su fase de construcciÃ³n. Son equivalentes a los
`â€œBuild Stepsâ€` que vemos al crear un `job Freestyle` desde la interfaz de `Jenkins`, pero expresados como cÃ³digo
dentro del `Job DSL`.

### ğŸ§± Â¿QuÃ© son los Steps?

Los `steps` son `instrucciones de ejecuciÃ³n` que Jenkins corre dentro del job. Pueden ser:

- ğŸ–¥ï¸ Comandos de shell/batch.
- ğŸ”§ Construcciones con herramientas (Maven, Gradle, Ant).
- ğŸ“¦ Scripts almacenados en el repositorio.
- ğŸš€ Invocaciones de pipelines, scripts Groovy, etc.

Ejemplo bÃ¡sico desde la documentaciÃ³n

````groovy
job('example') {
    steps {
        shell('echo START')
        gradle('check')
    }
}
````

âœ”ï¸ En este ejemplo se ejecuta un comando shell y luego una tarea de Gradle.

#### ğŸ“š Consultando documentaciÃ³n oficial

La referencia completa se encuentra aquÃ­:
[ğŸ”— Job DSL Plugin â€º FreeStyleJob â€º steps](https://jenkinsci.github.io/job-dsl-plugin/#method/javaposse.jobdsl.dsl.jobs.FreeStyleJob.steps)

![26.png](assets/section-12/26.png)

### ğŸ› ï¸ Agregando Steps en nuestro Seed Job dsl-job

Vamos a actualizar el DSL para que el job generado (`ejemplo-job-DSL`) ejecute un script del repositorio:

ğŸ“ `dsl-job` â†’ `Configure` â†’ `Build Steps` â†’ `Process Job DSLs`

Agregamos:

````groovy
job('ejemplo-job-DSL') {
    description('Job DSL de ejemplo para el curso de Jenkins')
    scm {
        git('https://github.com/macloujulian/jenkins.job.parametrizado.git', 'main') { node ->
            node / gitConfigName('MartÃ­n DÃ­az')
            node / gitConfigEmail('magadiflo@gmail.com')
        }
    }
    parameters {
        stringParam('NAME', 'Milagritos', 'ParÃ¡metro de cadena para el Job Booleano')
        choiceParam('PLANET', ['Mercurio', 'Venus', 'Tierra', 'Marte', 'JÃºpiter', 'Saturno', 'Urano', 'Neptuno', 'PlutÃ³n'], 'Lista de parÃ¡metros')
        booleanParam('AGENT', false)
    }
    triggers {
        cron('H/7 * * * *')
    }
    steps {
        shell('bash jobscript.sh')
    }
}
````

### ğŸ“ Â¿QuÃ© hace este Step?

````groovy
shell('bash jobscript.sh')
````

Este comando:

- Invoca el shell local del agente donde corre el job.
- Ejecuta el archivo `jobscript.sh` presente en el repositorio clonado.

ğŸ’¡ En entornos reales, siempre se acostumbra:

- Validar permisos de ejecuciÃ³n (chmod +x jobscript.sh)
- Evitar comandos inline largos.
- Mantener los scripts versionados dentro del repo (como hacemos aquÃ­).

![27.png](assets/section-12/27.png)

### â–¶ï¸ Ejecutando el Seed Job

DespuÃ©s de hacer clic en `Construir ahora`, Jenkins podrÃ­a requerir aprobaciÃ³n del script:

ğŸ“ `Manage Jenkins` â†’ `In-process Script Approval`

Una vez aprobado, la segunda ejecuciÃ³n debe completarse sin errores:

![28.png](assets/section-12/28.png)

### ğŸ” Verificando el Step en el job generado

Ahora revisamos el job creado `ejemplo-job-DSL`:

ğŸ“ `ejemplo-job-DSL` â†’ `Configure` â†’ `Build Steps`

VerÃ¡s reflejado el comando que definimos en el DSL:

![29.png](assets/section-12/29.png)
