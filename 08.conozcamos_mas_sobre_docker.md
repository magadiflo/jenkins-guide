# ğŸš€ SecciÃ³n 8: Conozcamos mÃ¡s sobre Docker en Jenkins

En esta secciÃ³n aprenderemos cÃ³mo hacer que `Jenkins pueda ejecutar comandos Docker desde dentro de su contenedor`, una
necesidad tÃ­pica cuando `Jenkins` realiza tareas como:

- Construir imÃ¡genes Docker.
- Ejecutar contenedores como parte de un pipeline.
- Desplegar microservicios.
- Ejecutar pruebas con Testcontainers.
- Automatizar procesos CI/CD que dependen del Docker Engine.

La clave no es instalar Docker completo dentro de Jenkins, sino `usar el Docker Engine del host` (tu mÃ¡quina o
servidor).

Para lograr esto aplicaremos el enfoque estÃ¡ndar utilizado en empresas:

> âœ”ï¸ `DooD` â€“ Docker Outside of Docker

Esto implica dos pasos esenciales:

1. `Instalar Docker CLI` dentro del contenedor de `Jenkins`. Esto permite ejecutar comandos como `docker build`,
   `docker run`, `docker compose`, etc.
2. `Montar el socket del host` (`/var/run/docker.sock`). Esto permite que el `Docker CLI` que estÃ¡ dentro de Jenkins
   controle el `Docker Engine real` que corre en el host.

> ğŸ’¡ Este es el patrÃ³n recomendado por `Docker`, `Jenkins` y la mayorÃ­a de empresas que implementan `CI/CD`
> con contenedores.

## ğŸ³ Instalando Docker CLI en el contenedor de Jenkins

Para agregar `Docker CLI` a `Jenkins`, construiremos una imagen personalizada basada en la imagen oficial:

- ğŸ“Œ `jenkins/jenkins:2.535-jdk21`

Esto nos permitirÃ¡:

- Instalar Docker CLI durante el build.
- Agregar Docker Compose v2 (`docker compose`).
- Trabajar con permisos correctos para usar el socket Docker.

### ğŸ§± 1. Obtener el GID del socket Docker

Antes de configurar el `Dockerfile`, necesitamos identificar el `GID (Group ID)` del archivo especial que expone
el `Docker Engine`: `/var/run/docker.sock`.

En `Docker Desktop` (`Windows/Mac`), este socket vive dentro de la `VM interna (WSL2/Hyper-V)`, pero podemos consultar
sus permisos usando un contenedor temporal:

````bash
D:\programming\jenkins\jenkins-guide (section-08 -> origin)                                            
$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock alpine stat -c '%g' /var/run/docker.sock
'0'                                                                                                    
````

ğŸ’¡ Â¿QuÃ© significa este valor?

- El `GID` indica `quÃ© grupo es dueÃ±o del socket`.
- `GID = 0` equivale al grupo `root`.
- En Docker Desktop:
    - El socket siempre pertenece a `root:root`.
    - No existe un grupo `docker` como en Linux nativo.
- Por lo tanto, para que `Jenkins` pueda ejecutar comandos Docker, debemos `agregar al usuario` `jenkins` al grupo
  `root` dentro del contenedor.

Con esa informaciÃ³n lista, pasamos al `Dockerfile`.

### ğŸ§± 2. Dockerfile personalizado

````Dockerfile
FROM jenkins/jenkins:2.535-jdk21

USER root

# Instalar Docker CLI + Docker Compose plugin
RUN apt-get update && \
    apt-get install -y \
        apt-transport-https \
        ca-certificates \
        curl \
        gnupg \
        lsb-release && \
    curl -fsSL https://download.docker.com/linux/debian/gpg | \
        gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg && \
    echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | \
        tee /etc/apt/sources.list.d/docker.list > /dev/null && \
    apt-get update && \
    apt-get install -y docker-ce-cli docker-compose-plugin && \
    rm -rf /var/lib/apt/lists/*

# Como el GID es 0 (root), agregaremos al usuario jenkins al grupo root
RUN usermod -aG root jenkins

USER jenkins
````

### ğŸ” ExplicaciÃ³n detallada

- `FROM jenkins/jenkins:2.535-jdk21`
    - Usamos la imagen oficial de `Jenkins` en su versiÃ³n actual con soporte para JDK 21.
    - Esta serÃ¡ la base sobre la cual aÃ±adiremos las herramientas necesarias.
- `USER root`
    - Cambiamos al usuario `root` para instalar paquetes y modificar grupos. Lo cambiamos de manera temporal,
      ya que mÃ¡s adelante lo dejaremos con el `USER jenkins`.
- `RUN apt-get update &&...`
    - Instalamos el `Docker CLI` (`docker-ce-cli`) para poder ejecutar comandos Docker dentro del contenedor.
    - Instalamos el plugin de `Docker Compose` (`docker-compose-plugin`) para soportar pipelines que usen
      `docker compose`.
    - Limpiamos la cachÃ© de `apt` para reducir el tamaÃ±o de la imagen.
    - âš ï¸ `Nota tÃ©cnica`: AquÃ­ `no instalamos el daemon de Docker`, solo el `CLI`. El daemon ya corre en el host y se
      accede vÃ­a el socket. La prÃ¡ctica correcta es que `Jenkins` use el `Docker Engine` del host.
- Acceso al `Docker Socket`
    - Sin permisos adecuados, Jenkins mostrarÃ¡ errores como:
    ````bash
    $ docker container ls -a 
      permission denied while trying to connect to the docker API at unix:///var/run/docker.sock
    ````
  Esto ocurre porque:
    - Jenkins corre como usuario `jenkins` (`no root`).
    - El socket pertenece a `root:root` (GID = 0).
- `RUN usermod -aG root jenkins`, agregando a Jenkins al grupo correcto.
    - Dado que en `Docker Desktop` el `socket` es propiedad del grupo `root`, aÃ±adimos al usuario `jenkins` a ese grupo.
    - Esto evita tener que ejecutar `chown` manualmente dentro del contenedor y evita que se pierdan los permisos con
      cada reinicio.
- `USER jenkins`
    - Las imÃ¡genes oficiales de `Jenkins` vienen preparadas para ejecutarse bajo el usuario `jenkins` por razones de
      seguridad y compatibilidad con plugins.
    - Solo volvemos a este usuario luego de la instalaciÃ³n.

## ğŸ”§ Montar el socket del host (`/var/run/docker.sock`)

El objetivo de esta configuraciÃ³n es permitir que `Jenkins`, **ejecutÃ¡ndose dentro de un contenedor,
pueda interactuar con el Docker Engine del host**. Esto es fundamental cuando Jenkins necesita:

- Construir imÃ¡genes Docker.
- Ejecutar contenedores como parte de un pipeline.
- Desplegar microservicios.
- Ejecutar pruebas que dependen de contenedores (Testcontainers, integraciÃ³n, etc.).

Para lograrlo, combinamos dos piezas clave:

1. `Una imagen personalizada` con Docker CLI (vista en la secciÃ³n anterior).
2. `El montaje del socket del host` (`/var/run/docker.sock`) para acceder al Docker Engine real.

A continuaciÃ³n, se muestra el archivo `compose.yml` actualizado.

### ğŸ³ compose.yml con acceso al Docker Host

````yml
services:
  s-jenkins:
    build:
      context: .
    image: jenkins
    container_name: c-jenkins
    restart: unless-stopped
    ports:
      - '8080:8080'
      - '50000:50000'
    volumes:
      - jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - jenkins-net

volumes:
  jenkins_home:
    name: jenkins_home

networks:
  jenkins-net:
    name: jenkins-net
````

### ğŸ“˜ ExplicaciÃ³n detallada del archivo

- `services.s-jenkins.build.context= .`
    - Definimos el servicio `s-jenkins`.
    - Usamos `build` para construir la imagen personalizada a partir del `Dockerfile` en el directorio actual (`.`).
- `image: jenkins`
    - Nombramos la imagen resultante como `jenkins`.
    - Esto facilita su referencia en otros proyectos.
- `container_name: c-jenkins`
    - Asignamos un nombre fijo al contenedor: `c-jenkins`.
    - Esto simplifica comandos como `docker container exec -it c-jenkins /bin/sh`.
- `restart: unless-stopped`
    - Configuramos el contenedor para reiniciarse automÃ¡ticamente, excepto si se detiene manualmente.
- Exponemos los puertos necesarios:
    - `8080`: acceso web a Jenkins.
    - `50000`: comunicaciÃ³n con agentes remotos.
- Volumes
    - `jenkins_home` volumen nombrado para persistir la configuraciÃ³n y datos de Jenkins.
    - `/var/run/docker.sock`: bind mount del socket Docker del host.
    - âš ï¸ Nota tÃ©cnica: Este socket es lo que permite que el `Docker CLI` dentro del contenedor se comunique con el
      daemon del host.
    - En Windows, si Jenkins corre como usuario `jenkins`, se generan errores de permisos. Por eso usamos `USER root`
      en el `Dockerfile`.

### ğŸ“ Â¿DÃ³nde estÃ¡ `/var/run/docker.sock` si estÃ¡s en Windows?

En sistemas Linux, ese archivo existe fÃ­sicamente en `/var/run/docker.sock`. Pero en Windows, especialmente si usas
`Docker Desktop`, el entorno es diferente:

#### Â¿QuÃ© pasa en Windows?

- Docker Desktop para Windows corre sobre una mÃ¡quina virtual ligera (WSL2 o Hyper-V).
- El archivo `/var/run/docker.sock` no estÃ¡ en tu sistema de archivos Windows directamente  (no en `C:\` ni `D:\`),
  sino dentro de esa `VM` de `WSL2` que Docker Desktop gestiona automÃ¡ticamente.
- Cuando usas Docker Compose en Windows, `Docker Desktop` emula esa ruta para que el `bind mount` funcione como si
  estuvieras en Linux.

> âœ… `ConclusiÃ³n`: Aunque no veas `/var/run/docker.sock` en tu disco `C:`, `Docker Desktop` lo expone virtualmente para
> que puedas usarlo en bind mounts como si estuvieras en Linux.
>
> Por eso esta lÃ­nea funciona igual en Windows, Mac y Linux: `/var/run/docker.sock:/var/run/docker.sock`.
>
> ğŸ’¡ `En la prÃ¡ctica`: No necesitas hacer nada especial en Windows. Docker Desktop se encarga de todo automÃ¡ticamente.

### ğŸ“Œ Diferencia entre volumen y bind mount

| Tipo         | Â¿QuÃ© es?                                     | Ejemplo                                      | Â¿QuiÃ©n lo gestiona?       |
|--------------|----------------------------------------------|----------------------------------------------|---------------------------|
| `Bind mount` | Montaje directo de una ruta del host         | `/var/run/docker.sock:/var/run/docker.sock ` | TÃº lo defines manualmente |
| `Volume`     | Ãrea gestionada por Docker para persistencia | `jenkins_home:/var/jenkins_home`             | Docker lo crea y gestiona |

#### ğŸ§  Nota tÃ©cnica sobre bind mounts en Windows

> En Windows, los `bind mounts` usan rutas como `D:\data:/app/data`. Sin embargo, rutas como `/var/run/docker.sock`
> funcionan porque `Docker Desktop` las emula internamente para permitir acceso al daemon Docker desde contenedores.

## Ejecutando nuevo contenedor de Jenkins

Luego de haber creado el `Dockerfile` y tenerlo referenciado en el `compose.yml`, vamos a detener el contenedor de
jenkins que tenemos corriendo:

````bash
D:\programming\jenkins\jenkins-guide (section-08)
$ docker compose -f ./docker/compose.yml down
````

Ahora ejecutamos nuevamente el docker compose pero para levantar el contenedor de jenkins que ahora usarÃ¡ el Dockerfile
para la creaciÃ³n del contenedor.

````bash
D:\programming\jenkins\jenkins-guide (section-08 -> origin)                                                               
$ docker compose -f ./docker/compose.yml up -d --build                                                                    
[+] Building 0.6s (9/9) FINISHED                                                                                          
 => [internal] load local bake definitions                                                                            0.0s
 => => reading from stdin 549B                                                                                        0.0s
 => [internal] load build definition from Dockerfile                                                                  0.0s
 => => transferring dockerfile: 913B                                                                                  0.0s
 => [internal] load metadata for docker.io/jenkins/jenkins:2.535-jdk21                                                0.0s
 => [internal] load .dockerignore                                                                                     0.0s
 => => transferring context: 2B                                                                                       0.0s
 => [1/3] FROM docker.io/jenkins/jenkins:2.535-jdk21                                                                  0.0s
 => CACHED [2/3] RUN apt-get update &&     apt-get install -y         apt-transport-https         ca-certificates     0.0s
 => CACHED [3/3] RUN usermod -aG root jenkins                                                                         0.0s
 => exporting to image                                                                                                0.0s
 => => exporting layers                                                                                               0.0s
 => => writing image sha256:cb83a20c9055fc3b25515fe4f985bd18dd6153d172e00ba03d0c54dc30109760                          0.0s
 => => naming to docker.io/library/jenkins                                                                            0.0s
 => resolving provenance for metadata file                                                                            0.0s
[+] Running 3/3                                                                                                           
 âœ” jenkins              Built                                                                                         0.0s
 âœ” Network jenkins-net  Created                                                                                       0.0s
 âœ” Container c-jenkins  Started                                                                                       0.5s                                                                                                                                                                                                                                                                                                                                                                                                    
````

### ğŸ’¡ Â¿Por quÃ© usar `--build`?

Porque cuando cambias el `Dockerfile` o cualquier archivo que forme parte del `build context`, `Docker Compose` podrÃ­a
reutilizar una imagen cacheada. Con `--build`, fuerzas explÃ­citamente a que se genere una `nueva imagen`,
garantizando que:

- Se instale la versiÃ³n correcta del `Docker CLI` dentro del contenedor.
- Cualquier cambio en el `Dockerfile` se refleje inmediatamente.

## âœ”ï¸ Verificando construcciÃ³n del nuevo contenedor

Luego de haber ejecutado el nuevo docker compose, verificamos que la imagen personalizada de Jenkins se haya creado
correctamente.

````bash
$ docker image ls
REPOSITORY            TAG                        IMAGE ID       CREATED          SIZE
jenkins               latest                     cb83a20c9055   34 minutes ago   697MB
jenkins/jenkins       2.535-jdk21                84444d75a07c   2 weeks ago      491MB
````

Observamos dos imÃ¡genes:

- `jenkins/jenkins:2.535-jdk21` â†’ Es la imagen base oficial que utilizamos en nuestro Dockerfile.
- `jenkins:latest` â†’ Es la imagen personalizada, construida por Docker Compose usando nuestro Dockerfile
  (con Docker CLI instalado).

Listamos los contenedores donde vemos nuestro `c-jenkins` pero ahora usando la nueva imagen `jenkins`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS                                                                                          NAMES
4f3d6c1a282c   jenkins   "/usr/bin/tini -- /uâ€¦"   About a minute ago   Up About a minute   0.0.0.0:8080->8080/tcp, [::]:8080->8080/tcp, 0.0.0.0:50000->50000/tcp, [::]:50000->50000/tcp   c-jenkins
````

## ğŸ³ Ejecutando comandos de Docker desde dentro del contenedor de Jenkins

Ahora que tenemos nuestro nuevo contenedor de `Jenkins` construido y en ejecuciÃ³n, probamos si realmente puede
interactuar con el `Docker Host`. Para ello ingresamos al contenedor y ejecutamos algunos comandos de `Docker`:

````bash
$ docker container exec -it c-jenkins /bin/sh
$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS                                                                                          NAMES
4f3d6c1a282c   jenkins   "/usr/bin/tini -- /uâ€¦"   About a minute ago   Up About a minute   0.0.0.0:8080->8080/tcp, [::]:8080->8080/tcp, 0.0.0.0:50000->50000/tcp, [::]:50000->50000/tcp   c-jenkins
$ docker image ls
i Info â†’   U  In Use
IMAGE                                ID             DISK USAGE   CONTENT SIZE   EXTRA
alpine:latest                        706db57fb206       8.32MB             0B
apache/kafka:4.1.0                   a183a690a3a6        437MB             0B
grafana/grafana:12.1.1               0a7de979b313        723MB             0B
grafana/loki:3.5.5                   fd1a879e62ca        123MB             0B
grafana/promtail:3.5.5               83598d9322f4        198MB             0B
grafana/tempo:2.8.2                  08c4147d7e1e        118MB             0B
jenkins/jenkins:2.535-jdk21          84444d75a07c        491MB             0B
jenkins:latest                       cb83a20c9055        697MB             0B    U
mysql:8.0.41-debian                  4340b8ad7a7c        610MB             0B
postgres:17-alpine                   f40315d0e8a6        279MB             0B
prom/prometheus:v3.5.0               a3bc50fcb50f        313MB             0B
redis:8.0.3-alpine                   c25e2f66b829       60.5MB             0B
sonarqube:25.10.0.114319-community   047bd8988268       1.23GB             0B
testcontainers/ryuk:0.12.0           a926383422af       15.8MB             0B
$ docker volume ls
DRIVER    VOLUME NAME
local     jenkins_home
$ docker network ls
NETWORK ID     NAME          DRIVER    SCOPE
a1554fbcb48a   bridge        bridge    local
e067f6421fbb   host          host      local
d37d985b5ec4   jenkins-net   bridge    local
10b2c1c97ecf   none          null      local
$
````

Si salimos del contenedor y ejecutamos los comandos docker fuera, veremos que obtenemos los mismos resultados que
ejecutÃ¡ndolos dentro del contenedor.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                                                                          NAMES
4f3d6c1a282c   jenkins   "/usr/bin/tini -- /uâ€¦"   4 minutes ago   Up 4 minutes   0.0.0.0:8080->8080/tcp, [::]:8080->8080/tcp, 0.0.0.0:50000->50000/tcp, [::]:50000->50000/tcp   c-jenkins
````

Resultados:

- Se listan los mismos contenedores, imÃ¡genes, volÃºmenes y redes que en el host.
- âœ… Jenkins tiene acceso completo al Docker Host gracias al `socket` y al uso de `USER root`.
- Esto confirma que nuestro entorno `DooD` â€“ `Docker-outside-of-Docker` estÃ¡ funcionando correctamente.

## ğŸ“Œ ConclusiÃ³n

- `Problema de permisos`: En `Windows` + `Docker Desktop`, el usuario `jenkins` no puede acceder al socket.
- `SoluciÃ³n aplicada`: Definir `USER root` en el `Dockerfile`.
- `ConfiguraciÃ³n lograda`:
    - Jenkins con Docker CLI instalado
    - Jenkins usando el Docker Compose plugin
    - Acceso total al Docker Engine del host vÃ­a `/var/run/docker.sock`
    - Sin necesidad de instalar Docker Engine dentro del contenedor (âš ï¸ mala prÃ¡ctica evitada)
- Ventaja del enfoque `DooD`:
    - âœ”ï¸ Ligero
    - âœ”ï¸ Seguro
    - âœ”ï¸ FÃ¡cil de mantener
    - âœ”ï¸ Usado ampliamente en pipelines reales de CI/CD
