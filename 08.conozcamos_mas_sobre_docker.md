# üöÄ Secci√≥n 8: Conozcamos m√°s sobre Docker en Jenkins

En esta secci√≥n aprenderemos c√≥mo hacer que `Jenkins pueda ejecutar comandos Docker desde dentro de su contenedor`, una
necesidad t√≠pica cuando `Jenkins` realiza tareas como:

- Construir im√°genes Docker.
- Ejecutar contenedores como parte de un pipeline.
- Desplegar microservicios.
- Ejecutar pruebas con Testcontainers.
- Automatizar procesos CI/CD que dependen del Docker Engine.

La clave no es instalar Docker completo dentro de Jenkins, sino `usar el Docker Engine del host` (tu m√°quina o
servidor).

Para lograr esto aplicaremos el enfoque est√°ndar utilizado en empresas:

> ‚úîÔ∏è `DooD` ‚Äì Docker Outside of Docker

Esto implica dos pasos esenciales:

1. `Instalar Docker CLI` dentro del contenedor de `Jenkins`. Esto permite ejecutar comandos como `docker build`,
   `docker run`, `docker compose`, etc.
2. `Montar el socket del host` (`/var/run/docker.sock`). Esto permite que el `Docker CLI` que est√° dentro de Jenkins
   controle el `Docker Engine rea`l que corre en el host.

> üí° Este es el patr√≥n recomendado por `Docker`, `Jenkins` y la mayor√≠a de empresas que implementan `CI/CD`
> con contenedores.

## üê≥ 1. Instalando Docker CLI en el contenedor de Jenkins

Para agregar `Docker CLI` a `Jenkins`, construiremos una imagen personalizada basada en la imagen oficial:

- üìå `jenkins/jenkins:2.535-jdk21`

Esto nos permitir√°:

- Instalar Docker CLI durante el build.
- Agregar Docker Compose v2 (`docker compose`).
- Trabajar con permisos correctos para usar el socket Docker.

## üê≥ Instalando Docker CLI dentro del contenedor de Jenkins

### üß± Dockerfile personalizado

````Dockerfile
FROM jenkins/jenkins:2.535-jdk21

USER root

# Instalar Docker CLI + Docker Compose plugin
RUN apt-get update && \
    apt-get install -y \
        apt-transport-https \
        ca-certificates \
        curl \
        gnupg \
        lsb-release && \
    curl -fsSL https://download.docker.com/linux/debian/gpg | \
        gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg && \
    echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | \
        tee /etc/apt/sources.list.d/docker.list > /dev/null && \
    apt-get update && \
    apt-get install -y docker-ce-cli docker-compose-plugin && \
    rm -rf /var/lib/apt/lists/*
````

### üîç Explicaci√≥n detallada

- `FROM jenkins/jenkins:2.535-jdk21`
    - Usamos la imagen oficial de `Jenkins` en su versi√≥n actual con soporte para JDK 21.
    - Esta ser√° la base sobre la cual a√±adiremos las herramientas necesarias.
- `USER root`
    - Cambiamos al usuario `root` para poder instalar paquetes y tener permisos sobre el `socket Docker`.
    - ‚ö†Ô∏è Nota t√©cnica: En `Windows` + `Docker Desktop`, si `Jenkins` corre como usuario `jenkins`, no puede acceder
      al socket por permisos. Es decir, si Jenkins corre como usuario jenkins, cuando ejecutemos comandos de docker
      dentro del contenedor de jenkins, veremos errores como:
    ````bash
    $ docker container ls -a 
      permission denied while trying to connect to the docker API at unix:///var/run/docker.sock
    ````
    - Por eso definimos `root` aqu√≠, para evitar los problemas de permisos.
- `RUN apt-get update &&...`
    - Instalamos el `Docker CLI` (`docker-ce-cli`) para poder ejecutar comandos Docker dentro del contenedor.
    - Instalamos el plugin de `Docker Compose` (`docker-compose-plugin`) para soportar pipelines que usen
      `docker compose`.
    - Limpiamos la cach√© de `apt` para reducir el tama√±o de la imagen.
    - ‚ö†Ô∏è `Nota t√©cnica`: Aqu√≠ `no instalamos el daemon de Docker`, solo el `CLI`. El daemon ya corre en el host y se
      accede v√≠a el socket. La pr√°ctica correcta es que `Jenkins` use el `Docker Engine` del host.

## üîß Modificando el compose.yml (con acceso al Docker Host)

El objetivo de esta configuraci√≥n es permitir que `Jenkins`, **ejecut√°ndose dentro de un contenedor,
pueda interactuar con el Docker Engine del host**. Esto es fundamental cuando Jenkins necesita:

- Construir im√°genes Docker.
- Ejecutar contenedores como parte de un pipeline.
- Desplegar microservicios.
- Ejecutar pruebas que dependen de contenedores (Testcontainers, integraci√≥n, etc.).

Para lograrlo, combinamos dos piezas clave:

1. `Una imagen personalizada` con Docker CLI (vista en la secci√≥n anterior).
2. `El montaje del socket del host` (`/var/run/docker.sock`) para acceder al Docker Engine real.

A continuaci√≥n, se muestra el archivo `compose.yml` actualizado.

### üê≥ compose.yml con acceso al Docker Host

````yml
services:
  s-jenkins:
    build:
      context: .
    image: jenkins
    container_name: c-jenkins
    restart: unless-stopped
    ports:
      - '8080:8080'
      - '50000:50000'
    volumes:
      - jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - jenkins-net

volumes:
  jenkins_home:
    name: jenkins_home

networks:
  jenkins-net:
    name: jenkins-net
````

### üìò Explicaci√≥n detallada del archivo

- `services.s-jenkins.build.context= .`
    - Definimos el servicio `s-jenkins`.
    - Usamos `build` para construir la imagen personalizada a partir del `Dockerfile` en el directorio actual (`.`).
- `image: jenkins`
    - Nombramos la imagen resultante como `jenkins`.
    - Esto facilita su referencia en otros proyectos.
- `container_name: c-jenkins`
    - Asignamos un nombre fijo al contenedor: `c-jenkins`.
    - Esto simplifica comandos como `docker container exec -it c-jenkins /bin/sh`.
- `restart: unless-stopped`
    - Configuramos el contenedor para reiniciarse autom√°ticamente, excepto si se detiene manualmente.
- Exponemos los puertos necesarios:
    - `8080`: acceso web a Jenkins.
    - `50000`: comunicaci√≥n con agentes remotos.
- Volumes
    - `jenkins_home` volumen nombrado para persistir la configuraci√≥n y datos de Jenkins.
    - `/var/run/docker.sock`: bind mount del socket Docker del host.
    - ‚ö†Ô∏è Nota t√©cnica: Este socket es lo que permite que el `Docker CLI` dentro del contenedor se comunique con el
      daemon del host.
    - En Windows, si Jenkins corre como usuario `jenkins`, se generan errores de permisos. Por eso usamos `USER root`
      en el `Dockerfile`.

### üìÅ ¬øD√≥nde est√° `/var/run/docker.sock` si est√°s en Windows?

En sistemas Linux, ese archivo existe f√≠sicamente en `/var/run/docker.sock`. Pero en Windows, especialmente si usas
`Docker Desktop`, el entorno es diferente:

#### ¬øQu√© pasa en Windows?

- Docker Desktop para Windows corre sobre una m√°quina virtual ligera (WSL2 o Hyper-V).
- El archivo `/var/run/docker.sock` no est√° en tu sistema de archivos Windows directamente  (no en `C:\` ni `D:\`),
  sino dentro de esa `VM` de `WSL2` que Docker Desktop gestiona autom√°ticamente.
- Cuando usas Docker Compose en Windows, `Docker Desktop` emula esa ruta para que el `bind mount` funcione como si
  estuvieras en Linux.

> ‚úÖ `Conclusi√≥n`: Aunque no veas `/var/run/docker.sock` en tu disco `C:`, `Docker Desktop` lo expone virtualmente para
> que puedas usarlo en bind mounts como si estuvieras en Linux.
>
> Por eso esta l√≠nea funciona igual en Windows, Mac y Linux: `/var/run/docker.sock:/var/run/docker.sock`.
>
> üí° `En la pr√°ctica`: No necesitas hacer nada especial en Windows. Docker Desktop se encarga de todo autom√°ticamente.

### üìå Diferencia entre volumen y bind mount

| Tipo         | ¬øQu√© es?                                     | Ejemplo                                      | ¬øQui√©n lo gestiona?       |
|--------------|----------------------------------------------|----------------------------------------------|---------------------------|
| `Bind mount` | Montaje directo de una ruta del host         | `/var/run/docker.sock:/var/run/docker.sock ` | T√∫ lo defines manualmente |
| `Volume`     | √Årea gestionada por Docker para persistencia | `jenkins_home:/var/jenkins_home`             | Docker lo crea y gestiona |

#### üß† Nota t√©cnica sobre bind mounts en Windows

> En Windows, los `bind mounts` usan rutas como `D:\data:/app/data`. Sin embargo, rutas como `/var/run/docker.sock`
> funcionan porque `Docker Desktop` las emula internamente para permitir acceso al daemon Docker desde contenedores.

## Ejecutando nuevo contenedor de Jenkins

Luego de haber creado el `Dockerfile` y tenerlo referenciado en el `compose.yml`, vamos a detener el contenedor de
jenkins que tenemos corriendo:

````bash
D:\programming\jenkins\jenkins-guide (section-08)
$ docker compose -f ./docker/compose.yml down
````

Ahora ejecutamos nuevamente el docker compose pero para levantar el contenedor de jenkins que ahora usar√° el Dockerfile
para la creaci√≥n del contenedor.

````bash
D:\programming\jenkins\jenkins-guide (section-08)                                                                                                                                                                                
$ docker compose -f ./docker/compose.yml up -d --build                                                                                                                                                                           
[+] Building 0.6s (8/8) FINISHED                                                                                                                                                                                                 
 => [internal] load local bake definitions                                                                                                                                                                                       
 => => reading from stdin 549B                                                                                                                                                                                                   
 => [internal] load build definition from Dockerfile                                                                                                                                                                             
 => => transferring dockerfile: 792B                                                                                                                                                                                             
 => [internal] load metadata for docker.io/jenkins/jenkins:2.535-jdk21                                                                                                                                                           
 => [internal] load .dockerignore                                                                                                                                                                                                
 => => transferring context: 2B                                                                                                                                                                                                  
 => [1/2] FROM docker.io/jenkins/jenkins:2.535-jdk21                                                                                                                                                                             
 => CACHED [2/2] RUN apt-get update &&     apt-get install -y         apt-transport-https         ca-certificates         curl         gnupg         lsb-release &&     curl -fsSL https://download.docker.com/linux/debian/gpg |
 => exporting to image                                                                                                                                                                                                           
 => => exporting layers                                                                                                                                                                                                          
 => => writing image sha256:cba75513c86c18e4c0ec9c43a75f5c343584d7e7e367295cbafce3c3c4d2c5e7                                                                                                                                     
 => => naming to docker.io/library/jenkins                                                                                                                                                                                       
 => resolving provenance for metadata file                                                                                                                                                                                       
[+] Running 3/3                                                                                                                                                                                                                  
 ‚úî jenkins              Built                                                                                                                                                                                                    
 ‚úî Network jenkins-net  Created                                                                                                                                                                                                  
 ‚úî Container c-jenkins  Started                                                                                                                                                                                                   
````

### üí° ¬øPor qu√© usar `--build`?

Porque cuando cambias el `Dockerfile` o cualquier archivo que forme parte del `build context`, `Docker Compose` podr√≠a
reutilizar una imagen cacheada. Con `--build`, fuerzas expl√≠citamente a que se genere una `nueva imagen`,
garantizando que:

- Se instale la versi√≥n correcta del `Docker CLI` dentro del contenedor.
- Cualquier cambio en el `Dockerfile` se refleje inmediatamente.

## ‚úîÔ∏è Verificando construcci√≥n del nuevo contenedor

Luego de haber ejecutado el nuevo docker compose, verificamos que la imagen personalizada de Jenkins se haya creado
correctamente.

````bash
$ docker image ls
REPOSITORY            TAG                        IMAGE ID       CREATED         SIZE
jenkins               latest                     cba75513c86c   4 hours ago     697MB
jenkins/jenkins       2.535-jdk21                84444d75a07c   13 days ago     491MB
````

Observamos dos im√°genes:

- `jenkins/jenkins:2.535-jdk21` ‚Üí Es la imagen base oficial que utilizamos en nuestro Dockerfile.
- `jenkins:latest` ‚Üí Es la imagen personalizada, construida por Docker Compose usando nuestro Dockerfile
  (con Docker CLI instalado).

Listamos los contenedores donde vemos nuestro `c-jenkins` pero ahora usando la nueva imagen `jenkins`.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS              PORTS                                                                                          NAMES
547d539b9619   jenkins   "/usr/bin/tini -- /u‚Ä¶"   2 minutes ago   Up About a minute   0.0.0.0:8080->8080/tcp, [::]:8080->8080/tcp, 0.0.0.0:50000->50000/tcp, [::]:50000->50000/tcp   c-jenkins
````

## üê≥ Ejecutando comandos de Docker desde dentro del contenedor de Jenkins

Ahora que tenemos nuestro nuevo contenedor de `Jenkins` construido y en ejecuci√≥n, probamos si realmente puede
interactuar con el `Docker Host`. Para ello ingresamos al contenedor y ejecutamos algunos comandos de `Docker`:

````bash
$ docker container exec -it c-jenkins /bin/sh
# docker container ls -a
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                                                                          NAMES
547d539b9619   jenkins   "/usr/bin/tini -- /u‚Ä¶"   4 minutes ago   Up 4 minutes   0.0.0.0:8080->8080/tcp, [::]:8080->8080/tcp, 0.0.0.0:50000->50000/tcp, [::]:50000->50000/tcp   c-jenkins
# docker image ls
i Info ‚Üí   U  In Use
IMAGE                                ID             DISK USAGE   CONTENT SIZE   EXTRA
alpine:latest                        706db57fb206       8.32MB             0B
apache/kafka:4.1.0                   a183a690a3a6        437MB             0B
grafana/grafana:12.1.1               0a7de979b313        723MB             0B
grafana/loki:3.5.5                   fd1a879e62ca        123MB             0B
grafana/promtail:3.5.5               83598d9322f4        198MB             0B
grafana/tempo:2.8.2                  08c4147d7e1e        118MB             0B
jenkins/jenkins:2.535-jdk21          84444d75a07c        491MB             0B
jenkins:latest                       cba75513c86c        697MB             0B    U
mysql:8.0.41-debian                  4340b8ad7a7c        610MB             0B
postgres:17-alpine                   f40315d0e8a6        279MB             0B
prom/prometheus:v3.5.0               a3bc50fcb50f        313MB             0B
redis:8.0.3-alpine                   c25e2f66b829       60.5MB             0B
sonarqube:25.10.0.114319-community   047bd8988268       1.23GB             0B
testcontainers/ryuk:0.12.0           a926383422af       15.8MB             0B
# docker volume ls
DRIVER    VOLUME NAME
local     jenkins_home
# docker network ls
NETWORK ID     NAME          DRIVER    SCOPE
163f3ebb040c   bridge        bridge    local
e067f6421fbb   host          host      local
ca01d7564eab   jenkins-net   bridge    local
10b2c1c97ecf   none          null      local
# 
````

Resultados:

- Se listan los mismos contenedores, im√°genes, vol√∫menes y redes que en el host.
- ‚úÖ Jenkins tiene acceso completo al Docker Host gracias al `socket` y al uso de `USER root`.
- Esto confirma que nuestro entorno `DooD` ‚Äì `Docker-outside-of-Docker` est√° funcionando correctamente.

## üìå Conclusi√≥n

- `Problema de permisos`: En `Windows` + `Docker Desktop`, el usuario `jenkins` no puede acceder al socket.
- `Soluci√≥n aplicada`: Definir `USER root` en el `Dockerfile`.
- `Configuraci√≥n lograda`:
    - Jenkins con Docker CLI instalado
    - Jenkins usando el Docker Compose plugin
    - Acceso total al Docker Engine del host v√≠a `/var/run/docker.sock`
    - Sin necesidad de instalar Docker Engine dentro del contenedor (‚ö†Ô∏è mala pr√°ctica evitada)
- Ventaja del enfoque `DooD`:
    - ‚úîÔ∏è Ligero
    - ‚úîÔ∏è Seguro
    - ‚úîÔ∏è F√°cil de mantener
    - ‚úîÔ∏è Usado ampliamente en pipelines reales de CI/CD
