# âš™ï¸ SecciÃ³n 7: IntegraciÃ³n de Jenkins con una App Java + Maven

---

### ğŸš€ Objetivo de la secciÃ³n

En esta secciÃ³n implementaremos un `flujo completo de IntegraciÃ³n Continua (CI)` utilizando `Jenkins`, una aplicaciÃ³n
`Java con Maven` y un repositorio alojado en `GitHub`.

El objetivo es que Jenkins `detecte cambios en el cÃ³digo fuente`, descargue automÃ¡ticamente la Ãºltima versiÃ³n,
`compile el proyecto`, `ejecute pruebas unitarias` y `genere artefactos` listos para desplegar.

ğŸ’¡ Concepto clave:

> La `IntegraciÃ³n Continua (CI)` es una prÃ¡ctica esencial en `DevOps` que permite detectar errores de integraciÃ³n
> de forma temprana, garantizando que el software estÃ© siempre en un estado funcional y desplegable.

## ğŸ”— Flujo general de integraciÃ³n continua con Jenkins

A continuaciÃ³n, se detalla el flujo de trabajo que implementaremos paso a paso:

1. ğŸ”Œ `InstalaciÃ³n de plugins y configuraciÃ³n base`. Configuraremos los plugins requeridos por `Maven`, `Git` y
   `GitHub`, asÃ­ como las variables necesarias para la ejecuciÃ³n del pipeline.
2. â¬‡ï¸ `Pull del repositorio GitHub en Jenkins`. Jenkins clonarÃ¡ automÃ¡ticamente el repositorio del proyecto Maven cada
   vez que se detecten nuevos commits.
3. ğŸ—ï¸ `ConstrucciÃ³n del proyecto con Maven`. Se ejecutarÃ¡ el comando `mvn clean install` o equivalente para compilar el
   cÃ³digo fuente y generar los artefactos (`.jar` o `.war`).
4. ğŸ§ª `EjecuciÃ³n de pruebas unitarias`. Durante el build, Maven ejecutarÃ¡ las pruebas definidas con JUnit, Mockito, u
   otros frameworks de testing configurados en el proyecto.
5. â–¶ï¸ `EjecuciÃ³n de la aplicaciÃ³n`. Finalmente, Jenkins podrÃ¡ ejecutar o desplegar la aplicaciÃ³n, ya sea localmente o
   en un contenedor Docker, dependiendo del entorno.

### âš™ï¸ Jenkins + GitHub + Maven en acciÃ³n

El flujo completo serÃ¡ similar al siguiente:

````
[GitHub Repo] â”€â”€pushâ”€â”€â–¶ [Jenkins Job] â”€â”€build+testâ”€â”€â–¶ [Artefacto Maven listo para despliegue] 
````

Cada cambio en GitHub dispararÃ¡ una nueva ejecuciÃ³n automÃ¡tica en Jenkins, garantizando que la aplicaciÃ³n Java:

- Compile sin errores.
- Pase las pruebas unitarias.
- Genere un artefacto vÃ¡lido (por ejemplo, un `.jar` funcional).

## ğŸ”Œ 1. InstalaciÃ³n de plugins y configuraciÃ³n base

### ğŸ§© InstalaciÃ³n del plugin `Maven Integration Plugin`

Para comenzar con la integraciÃ³n continua usando una aplicaciÃ³n Java con Maven, primero debemos instalar el plugin que
permite a `Jenkins` ejecutar `builds Maven`.

1. Ve a: `Administrar Jenkins` â†’ `Plugins` â†’ `Available plugins`
2. Busca: `Maven Integration`
3. Selecciona el plugin y procede con la instalaciÃ³n.

![01.png](assets/section-07/01.png)

Este plugin no solo permite ejecutar builds Maven dentro de Jenkins, sino que ademÃ¡s:

- Integra la fase de build con el ciclo estÃ¡ndar de Jenkins (detecta pom.xml, usa el Maven home configurado en Tools y
  expone pasos Maven en freestyle jobs).
- Permite el seguimiento de artefactos generados, pruebas, reportes y resultados JUnit.
- Facilita la creaciÃ³n de proyectos tipo â€œMaven projectâ€ (si no se usa Pipeline).

> ğŸ’¡ `Nota`: aunque hoy en dÃ­a casi todo se implementa con Pipelines (Jenkinsfile), muchos plugins heredados siguen
> dependiendo de esta integraciÃ³n para reportes de pruebas, cobertura, etc.

En la siguiente pantalla se mostrarÃ¡ el progreso de instalaciÃ³n. Es recomendable marcar la opciÃ³n
`â€œReiniciar Jenkins cuando finalice la instalaciÃ³nâ€` para completar la configuraciÃ³n.

![02.png](assets/section-07/02.png)

Una vez reiniciado `Jenkins`, verifica que el plugin haya sido instalado correctamente:

- Navega a: `Installed plugins`
- Busca nuevamente `Maven`
- DeberÃ¡s ver `Maven Integration Plugin` en la lista

![03.png](assets/section-07/03.png)

### ğŸ§© VerificaciÃ³n de `GitHub Branch Source Plugin`

El plugin `GitHub Branch Source Plugin` viene instalado por defecto en la mayorÃ­a de distribuciones modernas de
`Jenkins`. No es necesario instalarlo manualmente, solo comprobar que estÃ© disponible.

![04.png](assets/section-07/04.png)

Este plugin hace mucho detrÃ¡s de cÃ¡maras para que la integraciÃ³n `Jenkinsâ€“GitHub` sea moderna y automÃ¡tica:

- Detectar ramas y pull requests (PRs) dinÃ¡micamente usando la API de GitHub.
- Configura automÃ¡ticamente Webhooks para que GitHub notifique a Jenkins de nuevos commits.
- Administra credenciales y conexiones a GitHub usando la integraciÃ³n con GitHub App o tokens personales.
- Crea y actualiza jobs de manera automÃ¡tica en un Multibranch Pipeline basados en el Jenkinsfile de cada rama.

> ğŸ’¡ Esto lo vuelve ideal para equipos que usan GitHub Flow o GitHub PR Flow, ya que Jenkins se adapta a los repos sin
> necesidad de crear jobs manuales.

### ğŸ› ï¸ ConfiguraciÃ³n de Maven dentro de Jenkins

Ahora que el plugin estÃ¡ instalado, debemos configurar `Maven` como herramienta global dentro de `Jenkins` para que
pueda usarse en cualquier `Job` o `Pipeline`.

1. Ir a: `Administrar Jenkins` â†’ `Tools`
2. DesplÃ¡zate hacia el final hasta la secciÃ³n `Instalaciones de Maven`
3. Haz clic en `+ AÃ±adir Maven`

![05.png](assets/section-07/05.png)

Completa los siguientes campos:

- Name: `Maven en Jenkins`
- Instalar automÃ¡ticamente: âœ”ï¸ `activado`
- Version: dejar la predeterminada (Jenkins descargarÃ¡ la versiÃ³n estable recomendada)

![06.png](assets/section-07/06.png)

Finalmente, haz clic en `Save`.

### âš™ï¸ ExplicaciÃ³n tÃ©cnica

- `â€œInstalar automÃ¡ticamenteâ€` permite que `Jenkins` descargue y mantenga la versiÃ³n configurada de `Maven` sin
  necesidad de instalarla manualmente en el servidor.
- En entornos corporativos, es comÃºn:
    - Definir versiones especÃ­ficas de Maven.
    - Instalar Maven en un directorio controlado.
    - Apuntar Jenkins a esa instalaciÃ³n para mantener consistencia entre entornos.

ğŸ’¡ Buena prÃ¡ctica:
> Define versiones fijas de herramientas (como `Maven` y `JDK`) para evitar inconsistencias entre builds generados en
> distintos momentos.

## â¬‡ï¸ 2. Pull del repositorio GitHub en Jenkins

En este apartado trabajaremos con el repositorio:

- [macloujulian/simple-java-maven-app](https://github.com/macloujulian/simple-java-maven-app) â†’ fork del repositorio
  oficial:
- [jenkins-docs/simple-java-maven-app](https://github.com/jenkins-docs/simple-java-maven-app)

ğŸ“Œ Este proyecto es perfecto para practicar CI porque contiene un `pom.xml`, cÃ³digo Java y mÃºltiples ejemplos de
`Jenkinsfile`, aunque lo del `Jenkinsfile` lo veremos en secciones mÃ¡s adelante.

### ğŸ” Â¿QuÃ© significa hacer un fork en GitHub?

Un `fork` es una copia completa de un repositorio que pasa a tu propia cuenta de `GitHub`.
Se utiliza tÃ­picamente para:

- Crear tu propia versiÃ³n de un proyecto.
- Probar cambios sin modificar el repo original.
- Enviar pull requests al repositorio padre.

En el mundo real es comÃºn que empresas forkeen repos open-source para agregarlos a su pipeline, parchearlos o
personalizarlos.

### ğŸ“ Repositorio con el que trabajaremos

![07.png](assets/section-07/07.png)

### ğŸ†• Crear un nuevo Job Freestyle

Creamos un job llamado `java_app_con_maven`:

![08.png](assets/section-07/08.png)

### ğŸ”— ConfiguraciÃ³n del Origen del CÃ³digo Fuente

En la pantalla de configuraciÃ³n:

1. Activamos Git en Source Code Management.
2. Indicamos el repositorio: `https://github.com/macloujulian/simple-java-maven-app.git`.
3. En Branch Specifier colocamos la rama: `master`.

> ğŸ“Œ `Nota`: En la mayorÃ­a de proyectos modernos se usa `main`; el curso utiliza `master` porque asÃ­ estÃ¡ configurado
> el repo.

![09.png](assets/section-07/09.png)

### â–¶ï¸ Ejecutando el primer build

Damos clic en `Construir ahora` y obtenemos un build exitoso:

![10.png](assets/section-07/10.png)

### ğŸ› ï¸ ExplicaciÃ³n del Console Output (paso a paso y profesional)

Si revisamos el `Console Output`, veremos la siguiente salida:

````bash
Started by user System Admin
Running as SYSTEM
Building in workspace /var/jenkins_home/workspace/java_app_con_maven
The recommended git tool is: NONE
No credentials specified
Cloning the remote Git repository
Cloning repository https://github.com/macloujulian/simple-java-maven-app.git
 > git init /var/jenkins_home/workspace/java_app_con_maven # timeout=10
Fetching upstream changes from https://github.com/macloujulian/simple-java-maven-app.git
 > git --version # timeout=10
 > git --version # 'git version 2.47.3'
 > git fetch --tags --force --progress -- https://github.com/macloujulian/simple-java-maven-app.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 > git config remote.origin.url https://github.com/macloujulian/simple-java-maven-app.git # timeout=10
 > git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
Avoid second fetch
 > git rev-parse refs/remotes/origin/master^{commit} # timeout=10
Checking out Revision 9396b7c42f467673997e3d5f60b9f460a734e178 (refs/remotes/origin/master)
 > git config core.sparsecheckout # timeout=10
 > git checkout -f 9396b7c42f467673997e3d5f60b9f460a734e178 # timeout=10
Commit message: "javamavenDSL3.groovy"
First time build. Skipping changelog.
Finished: SUCCESS 
````

### ğŸ” Â¿Por quÃ© no aparece git clone?

`Jenkins` no usa directamente `git clone`. En su lugar realiza una secuencia mÃ¡s controlada:

#### âœ”ï¸ Paso 1 â€” Inicializar un repo vacÃ­o

````bash
git init /var/jenkins_home/workspace/java_app_con_maven 
````

Crea un repositorio local vacÃ­o en el workspace del job.

#### âœ”ï¸ Paso 2 â€” Configurar el origen

````bash
git config remote.origin.url <repo-url>
````

Agrega el remoto `origin` apuntando al repositorio de `GitHub`.

#### âœ”ï¸ Paso 3 â€” Descarga todas las ramas

````bash
git fetch --tags --force --progress -- <repo-url> +refs/heads/*:refs/remotes/origin/* 
````

`fetch` es mÃ¡s eficiente y mÃ¡s controlable que `git clone`, por eso Jenkins lo usa.

#### âœ”ï¸ Paso 4 â€” Resolver el commit a usar

````bash
git rev-parse refs/remotes/origin/master 
````

Identifica el `SHA` exacto que debe construir.

#### âœ”ï¸ Paso 5 â€” Hacer checkout del commit

````bash
git checkout -f <sha> 
````

Se mueve la copia de trabajo al commit correcto.

### ğŸ’¡ Â¿Por quÃ© Jenkins usa init + fetch + checkout?

Porque:

- Controla exactamente quÃ© commit se construye.
- Permite builds reproducibles.
- Evita operaciones innecesarias en cada build.
- Se integra mejor con webhooks, multibranch y PRs.
- Permite comparar cambios entre builds.

En empresas, es la forma estÃ¡ndar: `Jenkins nunca usa â€œgit cloneâ€ directo`.

![11.png](assets/section-07/11.png)

### ğŸ“‚ Verificando el proyecto dentro del contenedor

Entramos al contenedor de Jenkins:

````bash
$ docker container exec -it c-jenkins /bin/sh
$ cd /var/jenkins_home/workspace/java_app_con_maven
$ ls -l
total 40
drwxr-xr-x 2 jenkins jenkins 4096 Nov 14 15:57 DSL
-rw-r--r-- 1 jenkins jenkins  111 Nov 14 15:57 Dockerfile
-rw-r--r-- 1 jenkins jenkins  180 Nov 14 15:57 Dockerfile2
-rw-r--r-- 1 jenkins jenkins  578 Nov 14 15:57 Jenkinsfile1
-rw-r--r-- 1 jenkins jenkins 1133 Nov 14 15:57 Jenkinsfile3
-rw-r--r-- 1 jenkins jenkins 1854 Nov 14 15:57 Jenkinsfile4
-rw-r--r-- 1 jenkins jenkins  744 Nov 14 15:57 README.md
drwxr-xr-x 3 jenkins jenkins 4096 Nov 14 15:57 jenkins
-rw-r--r-- 1 jenkins jenkins 1383 Nov 14 15:57 pom.xml
drwxr-xr-x 4 jenkins jenkins 4096 Nov 14 15:57 src
$ cd src
$ ls -l
total 8
drwxr-xr-x 3 jenkins jenkins 4096 Nov 14 15:57 main
drwxr-xr-x 3 jenkins jenkins 4096 Nov 14 15:57 test
````

ğŸ“Œ AquÃ­ ya podemos ver el `cÃ³digo Java`, el `pom.xml` y varios `Jenkinsfiles`.

## ğŸ—ï¸ 3. ConstrucciÃ³n del proyecto con Maven

Continuamos con el job creado en el apartado anterior: `java_app_con_maven`.

### âš™ï¸ ConfiguraciÃ³n del Build con Maven

Navegamos a: `java_app_con_maven` â†’ `Configurar` â†’ `Build Steps` â†’ `Ejecutar tareas maven de nivel superior`

![12.png](assets/section-07/12.png)

Dentro de este formulario debemos completar los siguientes campos:

- VersiÃ³n de Maven: `Maven en Jenkins` (el nombre que asignamos en `Administrar Jenkins` â†’ `Tools`)
- Goals: Aunque solemos ejecutar Maven desde consola asÃ­:
    ````bash
    mvn -B clean package -DskipTests 
    ````
  En `Jenkins` no debemos anteponer el comando `mvn`, ya que el executor ya sabe que estamos invocando `Maven`. Por lo
  tanto, los goals quedan asÃ­:
    ````bash
    -B clean package -DskipTests
    ````

![13.png](assets/section-07/13.png)

**Donde**

- ğŸ“Œ `-B `(Batch Mode). Ejecuta Maven en modo no interactivo. Fundamental en CI/CD porque:
    - evita prompts que bloquearÃ­an el pipeline,
    - falla inmediatamente si necesita interacciÃ³n,
    - produce logs mÃ¡s lineales.
- ğŸ“Œ `clean`
    - Elimina el directorio `target/`.
    - Garantiza una compilaciÃ³n limpia y reproducible.
- ğŸ“Œ `package`
    - Compila y empaqueta la aplicaciÃ³n en un artefacto `(JAR/WAR)`.
- ğŸ“Œ `-DskipTests`. Indica a Maven que **omita la ejecuciÃ³n de pruebas**. Esto acelera el build, especialmente Ãºtil en:
    - validaciones rÃ¡pidas
    - pipelines de prueba funcional
    - validaciones previas a PR
- âœ”ï¸ Nota real del mundo empresarial
    - En pipelines productivos se suelen usar dos etapas separadas:
    - Build rÃ¡pido (`package -DskipTests`)
    - Etapa exclusiva de tests (`sin skipTests`)

### â–¶ï¸ Ejecutando el build

Damos clic en Construir ahora:

![14.png](assets/section-07/14.png)

Al finalizar, revisamos el `Console Output` y vemos:

![15.png](assets/section-07/15.png)

Perfecto, la construcciÃ³n de nuestra aplicaciÃ³n en un archivo `.jar` se ha realizado con Ã©xito, pues obtenemos el
mensaje `BUILD SUCCESS`.

![16.png](assets/section-07/16.png)

### ğŸ“¦ Verificando el artefacto .jar

Verificamos que el `my-app-1.0-SNAPSHOT.jar` se encuentre en el directorio que muestra la salida de consola del
job de jenkins: `/var/jenkins_home/workspace/java_app_con_maven/target/`.

````bash
$ docker container exec -it c-jenkins /bin/sh
$ cd /var/jenkins_home/workspace/java_app_con_maven/target/
$ ls -l
total 28
drwxr-xr-x 3 jenkins jenkins 4096 Nov 14 17:11 classes
drwxr-xr-x 3 jenkins jenkins 4096 Nov 14 17:11 generated-sources
drwxr-xr-x 3 jenkins jenkins 4096 Nov 14 17:11 generated-test-sources
drwxr-xr-x 2 jenkins jenkins 4096 Nov 14 17:11 maven-archiver
drwxr-xr-x 3 jenkins jenkins 4096 Nov 14 17:11 maven-status
-rw-r--r-- 1 jenkins jenkins 2676 Nov 14 17:11 my-app-1.0-SNAPSHOT.jar
drwxr-xr-x 3 jenkins jenkins 4096 Nov 14 17:11 test-classes
````

### ğŸ“£ Configurando notificaciones por Email y Slack

Es comÃºn en CI/CD configurar alertas para:

- builds fallidos (âŒ)
- builds que regresan a la normalidad (âœ…)

Esto permite a los equipos reaccionar rÃ¡pido ante fallas. Configuramos notificaciones dentro del job:

![17.png](assets/section-07/17.png)

Y agregamos tambiÃ©n notificaciones Slack:

![18.png](assets/section-07/18.png)

### ğŸ§ª Probando las notificaciones (fallo intencional)

Para verificar que las alertas funcionan, introducimos un error:

Cambiamos el goal:

- âŒ `package`
- âœ”ï¸ lo reemplazamos por `packag`

![19.png](assets/section-07/19.png)

Construimos nuevamente y, como se espera, el build falla:

![20.png](assets/section-07/20.png)

En el `Console Output` vemos que Jenkins enviÃ³ notificaciones:

![21.png](assets/section-07/21.png)

### ğŸ“¬ Email recibido

![22.png](assets/section-07/22.png)

### ğŸ’¬ NotificaciÃ³n Slack

![23.png](assets/section-07/23.png)
